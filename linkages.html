<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Linkages & Shock Analysis - USEEIO v2.0.1</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'IBM Plex Sans', -apple-system, sans-serif;
            background: #fff;
            color: #1a1a1a;
            min-height: 100vh;
            line-height: 1.5;
        }

        .app-header {
            background: #fff;
            border-bottom: 1px solid #e5e5e5;
            padding: 16px 32px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .app-title {
            font-size: 1.1rem;
            font-weight: 700;
            color: #1a1a1a;
        }

        .app-subtitle {
            font-size: 0.75rem;
            color: #666;
            margin-top: 2px;
        }

        .nav-tabs {
            display: flex;
            gap: 4px;
        }

        .nav-tab {
            padding: 8px 16px;
            font-size: 0.85rem;
            font-weight: 500;
            color: #666;
            cursor: pointer;
            transition: all 0.15s;
            border-bottom: 2px solid transparent;
        }

        .nav-tab:hover { color: #1a1a1a; }
        .nav-tab.active { 
            color: #1a1a1a; 
            border-bottom-color: #1a1a1a;
        }

        .main-container {
            padding: 32px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .page { display: none; }
        .page.active { display: block; }

        /* =============== LINKAGES PAGE STYLES =============== */
        .page-intro {
            max-width: 720px;
            margin-bottom: 32px;
        }

        .page-intro h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 12px;
        }

        .page-intro p {
            font-size: 0.9rem;
            color: #444;
            margin-bottom: 12px;
        }

        .linkages-grid {
            display: grid;
            grid-template-columns: 1fr 320px;
            gap: 32px;
        }

        .chart-card {
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            padding: 24px;
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 20px;
        }

        .chart-title {
            font-size: 0.9rem;
            font-weight: 700;
            color: #1a1a1a;
        }

        .chart-subtitle {
            font-size: 0.75rem;
            color: #666;
            margin-top: 4px;
        }

        .clear-selection {
            font-size: 0.75rem;
            color: #666;
            cursor: pointer;
            padding: 4px 8px;
            border: 1px solid #e5e5e5;
            border-radius: 3px;
            background: #fafafa;
            display: none;
        }

        .clear-selection:hover { background: #f0f0f0; }
        .clear-selection.visible { display: block; }

        #quadrant-chart {
            width: 100%;
            height: 480px;
        }

        .quadrant-legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
            margin-top: 24px;
            padding-top: 24px;
            border-top: 1px solid #e5e5e5;
        }

        .quadrant-item {
            display: flex;
            gap: 12px;
        }

        .quadrant-dot {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            flex-shrink: 0;
            margin-top: 3px;
        }

        .quadrant-dot.key { background: #16a34a; }
        .quadrant-dot.forward { background: #ea580c; }
        .quadrant-dot.backward { background: #2563eb; }
        .quadrant-dot.weak { background: #9ca3af; }

        .quadrant-text h4 {
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 4px;
        }

        .quadrant-text p {
            font-size: 0.7rem;
            color: #666;
            line-height: 1.4;
        }

        .sidebar-card {
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            padding: 20px;
            height: fit-content;
        }

        .sidebar-title {
            font-size: 0.8rem;
            font-weight: 700;
            margin-bottom: 16px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #1a1a1a;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            padding: 10px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .stat-row:last-of-type { border-bottom: none; }

        .stat-label {
            font-size: 0.8rem;
            color: #666;
        }

        .stat-value {
            font-size: 1rem;
            font-weight: 600;
            font-family: 'IBM Plex Mono', monospace;
        }

        .industry-search {
            width: 100%;
            background: #fafafa;
            border: 1px solid #e5e5e5;
            color: #1a1a1a;
            padding: 10px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-family: inherit;
            outline: none;
            margin: 16px 0 12px;
        }

        .industry-search:focus { border-color: #1a1a1a; }

        .industry-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .industry-item {
            padding: 10px 12px;
            border-radius: 3px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.1s;
            border-left: 3px solid transparent;
            background: #fafafa;
        }

        .industry-item:hover { background: #f0f0f0; }
        .industry-item.selected { background: #e5e5e5; border-left-color: #1a1a1a; }
        .industry-item.key-sector { border-left-color: #16a34a; }
        .industry-item.forward-oriented { border-left-color: #ea580c; }
        .industry-item.backward-oriented { border-left-color: #2563eb; }

        .industry-name {
            font-size: 0.8rem;
            font-weight: 500;
            margin-bottom: 2px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .industry-metrics {
            display: flex;
            gap: 12px;
            font-size: 0.7rem;
            color: #666;
            font-family: 'IBM Plex Mono', monospace;
        }

        /* =============== EXPLANATION SECTION =============== */
        .explanation-section {
            margin-top: 40px;
            padding-top: 32px;
            border-top: 1px solid #e5e5e5;
        }

        .explanation-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 20px;
        }

        .explanation-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 24px;
        }

        .explanation-card {
            padding: 20px;
            background: #fafafa;
            border-radius: 4px;
        }

        .explanation-card h4 {
            font-size: 0.9rem;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .explanation-card p {
            font-size: 0.8rem;
            color: #444;
            line-height: 1.6;
        }

        .explanation-card ul {
            margin: 12px 0 0 16px;
            font-size: 0.8rem;
            color: #444;
        }

        .explanation-card li {
            margin-bottom: 6px;
        }

        /* =============== SHOCK ANALYSIS PAGE STYLES =============== */
        .shock-container {
            display: flex;
            gap: 32px;
        }

        .shock-sidebar {
            width: 300px;
            flex-shrink: 0;
        }

        .shock-card {
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            overflow: hidden;
        }

        .shock-card-header {
            padding: 16px 20px;
            border-bottom: 1px solid #e5e5e5;
        }

        .shock-card-title {
            font-size: 0.85rem;
            font-weight: 700;
        }

        .shock-card-subtitle {
            font-size: 0.7rem;
            color: #666;
            margin-top: 2px;
        }

        .shock-tabs {
            display: flex;
            border-bottom: 1px solid #e5e5e5;
        }

        .shock-tab {
            flex: 1;
            padding: 10px;
            text-align: center;
            font-size: 0.75rem;
            font-weight: 500;
            color: #666;
            cursor: pointer;
            border-bottom: 2px solid transparent;
            transition: all 0.15s;
        }

        .shock-tab:hover { color: #1a1a1a; }
        .shock-tab.active { color: #1a1a1a; border-bottom-color: #1a1a1a; }

        .shock-content {
            padding: 16px;
            max-height: calc(100vh - 280px);
            overflow-y: auto;
        }

        .shock-panel { display: none; }
        .shock-panel.active { display: block; }

        .section-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 16px 0 8px;
        }

        .section-label:first-child { margin-top: 0; }

        .search-input {
            width: 100%;
            background: #fafafa;
            border: 1px solid #e5e5e5;
            color: #1a1a1a;
            padding: 8px 10px;
            border-radius: 3px;
            font-size: 0.8rem;
            font-family: inherit;
            outline: none;
            margin-bottom: 8px;
        }

        .search-input:focus { border-color: #1a1a1a; }

        .shock-industry-list {
            max-height: 160px;
            overflow-y: auto;
            margin-bottom: 12px;
        }

        .shock-industry-item {
            padding: 8px 10px;
            border-radius: 3px;
            margin-bottom: 3px;
            background: #fafafa;
            cursor: pointer;
            transition: all 0.1s;
            border: 1px solid transparent;
        }

        .shock-industry-item:hover { background: #f0f0f0; }
        .shock-industry-item.selected { border-color: #1a1a1a; background: #f0f0f0; }

        .shock-industry-name {
            font-size: 0.75rem;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .shock-industry-meta {
            font-size: 0.65rem;
            color: #888;
            margin-top: 2px;
        }

        .slider-group {
            margin-bottom: 12px;
        }

        .slider-label {
            font-size: 0.75rem;
            color: #666;
            margin-bottom: 6px;
            display: flex;
            justify-content: space-between;
        }

        .slider-value {
            font-family: 'IBM Plex Mono', monospace;
            font-weight: 600;
            color: #1a1a1a;
        }

        input[type="range"] {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            background: #e5e5e5;
            border-radius: 2px;
            outline: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #1a1a1a;
            border-radius: 50%;
            cursor: pointer;
        }

        .btn {
            width: 100%;
            background: #1a1a1a;
            border: none;
            color: #fff;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s;
            margin-top: 8px;
        }

        .btn:hover { background: #333; }
        .btn:disabled { opacity: 0.4; cursor: not-allowed; }

        .btn-outline {
            background: #fff;
            color: #666;
            border: 1px solid #e5e5e5;
        }

        .btn-outline:hover { background: #fafafa; }

        .results-panel {
            flex: 1;
            min-width: 0;
        }

        .results-header {
            margin-bottom: 24px;
        }

        .results-title {
            font-size: 1.1rem;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .results-subtitle {
            font-size: 0.8rem;
            color: #666;
        }

        .metrics-row {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 16px;
            margin-bottom: 24px;
        }

        .metric-card {
            background: #fafafa;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            padding: 16px;
        }

        .metric-label {
            font-size: 0.7rem;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            margin-bottom: 6px;
        }

        .metric-value {
            font-size: 1.5rem;
            font-weight: 700;
            font-family: 'IBM Plex Mono', monospace;
        }

        .metric-value.positive { color: #16a34a; }
        .metric-value.negative { color: #dc2626; }

        .metric-detail {
            font-size: 0.7rem;
            color: #888;
            margin-top: 4px;
        }

        .results-card {
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .results-card-title {
            font-size: 0.85rem;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .results-card-subtitle {
            font-size: 0.7rem;
            color: #666;
            margin-bottom: 16px;
        }

        .data-table {
            width: 100%;
            border-collapse: collapse;
        }

        .data-table th {
            text-align: left;
            padding: 8px 10px;
            font-size: 0.65rem;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            border-bottom: 1px solid #e5e5e5;
        }

        .data-table td {
            padding: 8px 10px;
            font-size: 0.8rem;
            border-bottom: 1px solid #f0f0f0;
        }

        .data-table tr:hover { background: #fafafa; }

        .bar-cell {
            height: 4px;
            background: #e5e5e5;
            border-radius: 2px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            border-radius: 2px;
            transition: width 0.3s;
        }

        .bar-fill.blue { background: #2563eb; }
        .bar-fill.red { background: #dc2626; }
        .bar-fill.orange { background: #ea580c; }

        .risk-badge {
            display: inline-block;
            padding: 2px 6px;
            border-radius: 2px;
            font-size: 0.6rem;
            font-weight: 600;
            text-transform: uppercase;
        }

        .risk-badge.high { background: #fef2f2; color: #dc2626; }
        .risk-badge.medium { background: #fff7ed; color: #ea580c; }
        .risk-badge.low { background: #f0fdf4; color: #16a34a; }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #888;
        }

        .empty-state-text {
            font-size: 0.9rem;
            margin-bottom: 8px;
        }

        .empty-state-hint {
            font-size: 0.75rem;
            color: #aaa;
        }

        .tooltip {
            position: fixed;
            pointer-events: none;
            background: #fff;
            border: 1px solid #e5e5e5;
            padding: 12px 16px;
            border-radius: 4px;
            font-size: 0.8rem;
            max-width: 300px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.1s;
        }

        .tooltip.visible { opacity: 1; }
        .tooltip-title { font-weight: 600; margin-bottom: 8px; }
        .tooltip-row { display: flex; justify-content: space-between; gap: 16px; margin-bottom: 3px; }
        .tooltip-label { color: #666; }
        .tooltip-value { font-family: 'IBM Plex Mono', monospace; font-weight: 500; }

        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #e5e5e5; border-radius: 3px; }
        ::-webkit-scrollbar-thumb:hover { background: #d0d0d0; }

        /* =============== CIRCULARITY PAGE STYLES =============== */
        .circularity-grid {
            display: grid;
            grid-template-columns: 1fr 300px;
            gap: 32px;
        }

        .flow-type-select {
            padding: 6px 28px 6px 10px;
            font-size: 0.8rem;
            font-weight: 500;
            color: #1a1a1a;
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            cursor: pointer;
            appearance: none;
            background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M3 4l3 3 3-3'/%3E%3C/svg%3E");
            background-repeat: no-repeat;
            background-position: right 8px center;
            font-family: inherit;
        }

        .flow-type-select:hover {
            border-color: #ccc;
        }

        .flow-type-select:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .network-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 10px 16px;
            background: #f8f9fa;
            border-bottom: 1px solid #e5e5e5;
        }

        .control-row {
            display: flex;
            gap: 16px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 3px;
            min-width: 85px;
        }

        .control-label {
            font-size: 0.65rem;
            font-weight: 500;
            color: #666;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.65rem;
            color: #1a1a1a;
            font-weight: 600;
        }

        .control-slider {
            width: 80px;
            height: 3px;
            appearance: none;
            background: #e5e5e5;
            border-radius: 2px;
            cursor: pointer;
        }

        .control-slider::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #fff;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            cursor: pointer;
        }

        .control-slider::-moz-range-thumb {
            width: 12px;
            height: 12px;
            background: #fff;
            border: 2px solid #3b82f6;
            border-radius: 50%;
            cursor: pointer;
        }

        .control-select {
            padding: 4px 8px;
            font-size: 0.7rem;
            font-weight: 500;
            color: #1a1a1a;
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 3px;
            cursor: pointer;
            font-family: inherit;
        }

        .control-checkbox {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.7rem;
            color: #666;
            cursor: pointer;
        }

        .control-checkbox input {
            cursor: pointer;
        }

        .reset-btn {
            padding: 4px 10px;
            font-size: 0.7rem;
            font-weight: 500;
            color: #666;
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 3px;
            cursor: pointer;
        }

        .reset-btn:hover {
            background: #f0f0f0;
            color: #1a1a1a;
        }

        .fullscreen-btn {
            padding: 4px 8px;
            font-size: 1rem;
            color: #666;
            background: #fff;
            border: 1px solid #e5e5e5;
            border-radius: 3px;
            cursor: pointer;
            line-height: 1;
        }

        .fullscreen-btn:hover {
            background: #f0f0f0;
            color: #1a1a1a;
        }

        /* Fullscreen mode */
        .chart-card.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 1000;
            border-radius: 0;
            margin: 0;
            max-width: none;
            display: flex;
            flex-direction: column;
        }

        .chart-card.fullscreen #network-chart {
            flex: 1;
            height: auto !important;
            min-height: 0;
        }

        .chart-card.fullscreen #network-chart svg {
            width: 100% !important;
            height: 100% !important;
        }

        .chart-card.fullscreen .chart-header {
            flex-shrink: 0;
        }

        .chart-card.fullscreen .network-controls {
            flex-shrink: 0;
        }

        .chart-card.fullscreen .fullscreen-btn {
            font-size: 1.2rem;
        }

        .fullscreen-btn .fs-close {
            display: none;
        }

        .chart-card.fullscreen .fullscreen-btn .fs-open {
            display: none;
        }

        .chart-card.fullscreen .fullscreen-btn .fs-close {
            display: inline;
        }

        .view-toggle {
            display: flex;
            border: 1px solid #e5e5e5;
            border-radius: 4px;
            overflow: hidden;
        }

        .view-btn {
            padding: 6px 12px;
            font-size: 0.75rem;
            font-weight: 500;
            color: #666;
            background: #fff;
            border: none;
            cursor: pointer;
            transition: all 0.15s;
        }

        .view-btn:not(:last-child) {
            border-right: 1px solid #e5e5e5;
        }

        .view-btn:hover {
            background: #fafafa;
        }

        .view-btn.active {
            background: #1a1a1a;
            color: #fff;
        }

        #chord-chart, #network-chart {
            width: 100%;
            height: 650px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
        }

        #chord-chart svg {
            overflow: visible;
        }

        #network-chart svg {
            overflow: hidden;
        }

        .chart-hint {
            position: absolute;
            bottom: 12px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            color: #888;
            background: rgba(255,255,255,0.9);
            padding: 4px 12px;
            border-radius: 4px;
            pointer-events: none;
        }

        .circularity-sidebar {
            height: fit-content;
        }

        .sector-detail-header {
            padding-bottom: 12px;
            border-bottom: 1px solid #f0f0f0;
            margin-bottom: 12px;
        }

        .sector-detail-name {
            font-size: 0.9rem;
            font-weight: 700;
            margin-bottom: 4px;
        }

        .sector-detail-output {
            font-size: 0.75rem;
            color: #666;
        }

        .sector-detail-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .sector-detail-label {
            font-size: 0.75rem;
            color: #666;
        }

        .sector-detail-value {
            font-size: 0.8rem;
            font-weight: 600;
            font-family: 'IBM Plex Mono', monospace;
        }

        .top-flows-list {
            max-height: 300px;
            overflow-y: auto;
        }

        .flow-item {
            padding: 10px 12px;
            background: #fafafa;
            border-radius: 3px;
            margin-bottom: 4px;
            cursor: pointer;
            transition: all 0.1s;
        }

        .flow-item:hover {
            background: #f0f0f0;
        }

        .flow-item.selected {
            background: #e5e5e5;
        }

        .flow-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .flow-item-sectors {
            font-size: 0.75rem;
            font-weight: 500;
        }

        .flow-item-value {
            font-size: 0.75rem;
            font-weight: 600;
            font-family: 'IBM Plex Mono', monospace;
        }

        .flow-item-bar {
            height: 3px;
            background: #e5e5e5;
            border-radius: 2px;
            overflow: hidden;
        }

        .flow-item-bar-fill {
            height: 100%;
            background: #2563eb;
            border-radius: 2px;
        }

        .flow-arrow {
            color: #888;
            margin: 0 4px;
        }

        .flow-self {
            color: #16a34a;
            font-size: 0.65rem;
            margin-left: 4px;
        }

        @media (max-width: 1100px) {
            .linkages-grid { grid-template-columns: 1fr; }
            .shock-container { flex-direction: column; }
            .shock-sidebar { width: 100%; }
            .metrics-row { grid-template-columns: repeat(2, 1fr); }
            .explanation-grid { grid-template-columns: 1fr; }
            .circularity-grid { grid-template-columns: 1fr; }
        }
    </style>
</head>
<body>
    <header class="app-header">
        <div>
            <div class="app-title">Economic Linkage Analysis</div>
            <div class="app-subtitle">USEEIO v2.0.1 ¬∑ 411 Industries</div>
        </div>
        <nav class="nav-tabs">
            <div class="nav-tab active" data-page="linkages">Linkages</div>
            <div class="nav-tab" data-page="shock">Shock Analysis</div>
            <div class="nav-tab" data-page="circularity">Circularity <span style="font-size:0.65rem;color:#888;margin-left:4px">Œ≤</span></div>
        </nav>
    </header>

    <main class="main-container">
        <!-- =============== LINKAGES PAGE =============== -->
        <div class="page active" id="page-linkages">
            <div class="page-intro">
                <h2>How Industries Connect</h2>
                <p>This chart shows how each of the 411 US industries relates to the rest of the economy. Industries that buy a lot from others (high <strong>backward linkage</strong>) appear further right. Industries that sell a lot to others (high <strong>forward linkage</strong>) appear higher up. Click any industry in the list to highlight it on the chart.</p>
            </div>

            <div class="linkages-grid">
                <div class="chart-card">
                    <div class="chart-header">
                        <div>
                            <div class="chart-title">Forward vs Backward Linkages</div>
                            <div class="chart-subtitle">Each dot is an industry. Size = annual output. Position = economic role.</div>
                        </div>
                        <button class="clear-selection" id="clear-selection" onclick="clearSelection()">Clear selection</button>
                    </div>
                    <div id="quadrant-chart"></div>
                    
                    <div class="quadrant-legend">
                        <div class="quadrant-item">
                            <div class="quadrant-dot key"></div>
                            <div class="quadrant-text">
                                <h4>Key Sectors</h4>
                                <p>Buy heavily from suppliers AND sell heavily to customers. Most interconnected industries (e.g., Steel, Chemicals).</p>
                            </div>
                        </div>
                        <div class="quadrant-item">
                            <div class="quadrant-dot forward"></div>
                            <div class="quadrant-text">
                                <h4>Forward Oriented</h4>
                                <p>Sell to many industries but don't buy much. Supply chain "sources" (e.g., Mining, Utilities, Wholesale).</p>
                            </div>
                        </div>
                        <div class="quadrant-item">
                            <div class="quadrant-dot backward"></div>
                            <div class="quadrant-text">
                                <h4>Backward Oriented</h4>
                                <p>Buy from many suppliers but fewer sell to. Demand drivers (e.g., Construction, Automobiles).</p>
                            </div>
                        </div>
                        <div class="quadrant-item">
                            <div class="quadrant-dot weak"></div>
                            <div class="quadrant-text">
                                <h4>Weak Linkages</h4>
                                <p>Relatively independent. Often service industries with limited inter-industry trade (e.g., Education, Personal services).</p>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="sidebar-card">
                    <div class="sidebar-title">Summary</div>
                    <div class="stat-row">
                        <span class="stat-label">Total industries</span>
                        <span class="stat-value" id="stat-total">411</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Key sectors</span>
                        <span class="stat-value" id="stat-key">‚Äî</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Avg backward linkage</span>
                        <span class="stat-value" id="stat-bl">1.00</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Avg forward linkage</span>
                        <span class="stat-value" id="stat-fl">1.00</span>
                    </div>

                    <input type="text" class="industry-search" id="linkage-search" placeholder="Search industries...">
                    
                    <div class="industry-list" id="industry-list"></div>
                </div>
            </div>

            <div class="explanation-section">
                <div class="explanation-title">Understanding Linkages</div>
                <div class="explanation-grid">
                    <div class="explanation-card">
                        <h4>What is a Backward Linkage?</h4>
                        <p>Backward linkage measures how much an industry <strong>buys from other industries</strong> to produce its output. Think of it as "demand pull" ‚Äî when this industry grows, it pulls demand from its suppliers.</p>
                        <ul>
                            <li><strong>High BL (>1):</strong> The industry relies heavily on inputs from many sectors. Growth here stimulates broad supplier activity.</li>
                            <li><strong>Low BL (<1):</strong> The industry is more self-contained or uses fewer intermediate inputs.</li>
                        </ul>
                        <p style="margin-top:12px"><strong>Example:</strong> Automobile manufacturing has high backward linkage because it buys steel, glass, electronics, plastics, and textiles from many industries.</p>
                    </div>
                    <div class="explanation-card">
                        <h4>What is a Forward Linkage?</h4>
                        <p>Forward linkage measures how much an industry <strong>sells to other industries</strong> as inputs to their production. Think of it as "supply push" ‚Äî this industry enables others to operate.</p>
                        <ul>
                            <li><strong>High FL (>1):</strong> Many industries depend on this sector's output. Disruptions here ripple widely.</li>
                            <li><strong>Low FL (<1):</strong> Output mainly goes to final consumers rather than other businesses.</li>
                        </ul>
                        <p style="margin-top:12px"><strong>Example:</strong> Electricity generation has high forward linkage because nearly every industry needs power to operate.</p>
                    </div>
                    <div class="explanation-card">
                        <h4>What does "Key Sector" mean?</h4>
                        <p>A <strong>key sector</strong> has both high backward AND high forward linkages (both above 1.0). These industries are the most interconnected in the economy.</p>
                        <p style="margin-top:8px">Key sectors are strategically important because:</p>
                        <ul>
                            <li>They create multiplier effects in both directions</li>
                            <li>Investment here has maximum economic ripple effect</li>
                            <li>Disruptions to key sectors impact the entire supply chain</li>
                        </ul>
                        <p style="margin-top:12px"><strong>Examples:</strong> Iron and steel, Basic chemicals, Petroleum refining, Plastics.</p>
                    </div>
                    <div class="explanation-card">
                        <h4>How to read the values</h4>
                        <p>Linkage values are <strong>normalized</strong> so that 1.0 represents the economy-wide average.</p>
                        <ul>
                            <li><strong>BL = 1.5</strong> means 50% more backward linkage than average</li>
                            <li><strong>FL = 0.8</strong> means 20% less forward linkage than average</li>
                            <li><strong>BL = 2.0</strong> means double the average input purchases</li>
                        </ul>
                        <p style="margin-top:12px">The size of each dot represents the industry's annual output in billions of dollars ‚Äî larger industries have bigger economic footprints.</p>
                    </div>
                </div>
            </div>
        </div>

        <!-- =============== SHOCK ANALYSIS PAGE =============== -->
        <div class="page" id="page-shock">
            <div class="page-intro">
                <h2>Economic Shock Simulator</h2>
                <p>Explore what happens when demand changes or costs increase in a specific industry. See how effects propagate through supply chains using input-output relationships.</p>
            </div>

            <div class="shock-container">
                <div class="shock-sidebar">
                    <div class="shock-card">
                        <div class="shock-card-header">
                            <div class="shock-card-title">Analysis Settings</div>
                            <div class="shock-card-subtitle">Select an industry and shock type</div>
                        </div>
                        
                        <div class="shock-tabs">
                            <div class="shock-tab active" data-tab="demand">Demand</div>
                            <div class="shock-tab" data-tab="cost">Cost</div>
                            <div class="shock-tab" data-tab="risk">Risk</div>
                        </div>

                        <div class="shock-content">
                            <!-- Demand Shock Panel -->
                            <div class="shock-panel active" id="panel-demand">
                                <div class="section-label">Industry</div>
                                <input type="text" class="search-input" id="search-demand" placeholder="Search...">
                                <div class="shock-industry-list" id="list-demand"></div>

                                <div class="section-label">Demand change</div>
                                <div class="slider-group">
                                    <div class="slider-label">
                                        <span>Final demand</span>
                                        <span class="slider-value" id="demand-value">+$1B</span>
                                    </div>
                                    <input type="range" id="demand-slider" min="-10" max="10" step="0.5" value="1">
                                </div>

                                <button class="btn" id="run-demand" disabled>Calculate impact</button>
                                <button class="btn btn-outline" id="clear-demand">Clear</button>
                            </div>

                            <!-- Cost Shock Panel -->
                            <div class="shock-panel" id="panel-cost">
                                <div class="section-label">Industry (cost source)</div>
                                <input type="text" class="search-input" id="search-cost" placeholder="Search...">
                                <div class="shock-industry-list" id="list-cost"></div>

                                <div class="section-label">Price increase</div>
                                <div class="slider-group">
                                    <div class="slider-label">
                                        <span>Cost change</span>
                                        <span class="slider-value" id="cost-value">+10%</span>
                                    </div>
                                    <input type="range" id="cost-slider" min="1" max="50" step="1" value="10">
                                </div>

                                <button class="btn" id="run-cost" disabled>Analyze propagation</button>
                                <button class="btn btn-outline" id="clear-cost">Clear</button>
                            </div>

                            <!-- Risk Analysis Panel -->
                            <div class="shock-panel" id="panel-risk">
                                <div class="section-label">About this analysis</div>
                                <p style="font-size: 0.75rem; color: #666; margin-bottom: 16px; line-height: 1.5;">
                                    Identifies industries most vulnerable to supply chain disruptions based on input concentration and pricing power.
                                </p>

                                <div class="section-label">Show risk levels</div>
                                <div class="slider-group">
                                    <div class="slider-label">
                                        <span>Threshold</span>
                                        <span class="slider-value" id="risk-threshold-value">Medium+</span>
                                    </div>
                                    <input type="range" id="risk-threshold" min="1" max="3" step="1" value="2">
                                </div>

                                <button class="btn" id="run-risk">Run analysis</button>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="results-panel">
                    <div class="results-header">
                        <div class="results-title" id="results-title">Results</div>
                        <div class="results-subtitle" id="results-subtitle">Select an industry and run analysis</div>
                    </div>
                    <div id="results-container">
                        <div class="empty-state">
                            <div class="empty-state-text">No analysis running</div>
                            <div class="empty-state-hint">Choose settings in the left panel and click a button to start</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- =============== CIRCULARITY PAGE =============== -->
        <div class="page" id="page-circularity">
            <div class="page-intro">
                <h2>Material & Waste Flows Between Sectors</h2>
                <p>Explore how materials, intermediate goods, and waste flow between the 20 major economic sectors. Switch between dollar flows and waste categories (Municipal Solid Waste, Construction & Demolition Debris, Hazardous Waste) to understand both economic and environmental interdependencies.</p>
            </div>

            <div class="circularity-grid">
                <div class="chart-card">
                    <div class="chart-header">
                        <div>
                            <div class="chart-title">Inter-Sector Flows</div>
                            <div class="chart-subtitle" id="chart-subtitle-circ">Line thickness = billions of dollars in intermediate goods traded annually</div>
                        </div>
                        <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;">
                            <select id="flow-type-select" class="flow-type-select">
                                <option value="dollars">üíµ Dollar Flows</option>
                                <option value="MSW">üóëÔ∏è MSW (Municipal Solid Waste)</option>
                                <option value="CDD">üèóÔ∏è CDD (Construction Debris)</option>
                                <option value="Hazardous">‚ò¢Ô∏è Hazardous Waste</option>
                            </select>
                            <div class="view-toggle">
                                <button class="view-btn active" data-view="network">Network</button>
                                <button class="view-btn" data-view="chord">Chord</button>
                            </div>
                            <label style="font-size:0.75rem;color:#666;">
                                <input type="checkbox" id="show-self-loops" style="margin-right:4px;">
                                Internal flows
                            </label>
                            <button class="clear-selection" id="clear-chord" onclick="clearChordSelection()" style="display:none;">Clear</button>
                        </div>
                    </div>
                    
                    <!-- Network Controls -->
                    <div id="network-controls" class="network-controls">
                        <div class="control-row">
                            <div class="control-group">
                                <label class="control-label">Layout</label>
                                <select id="layout-select" class="control-select">
                                    <option value="force">Force</option>
                                    <option value="radial">Radial</option>
                                    <option value="circular">Circular</option>
                                </select>
                            </div>
                            <div class="control-group">
                                <label class="control-label"># Industries <span id="sectors-value" class="control-value">20</span></label>
                                <input type="range" id="sectors-slider" min="5" max="100" value="20" class="control-slider">
                            </div>
                            <div class="control-group">
                                <label class="control-label">Min Flow <span id="threshold-value" class="control-value">$10B</span></label>
                                <input type="range" id="threshold-slider" min="0" max="100" value="10" class="control-slider">
                            </div>
                            <div class="control-group">
                                <label class="control-label">Min Links <span id="minlinks-value" class="control-value">0</span></label>
                                <input type="range" id="minlinks-slider" min="0" max="10" value="0" class="control-slider">
                            </div>
                        </div>
                        <div class="control-row">
                            <div class="control-group">
                                <label class="control-label">Node Size <span id="nodesize-value" class="control-value">100%</span></label>
                                <input type="range" id="nodesize-slider" min="50" max="200" value="100" class="control-slider">
                            </div>
                            <div class="control-group">
                                <label class="control-label">Repulsion <span id="charge-value" class="control-value">100%</span></label>
                                <input type="range" id="charge-slider" min="20" max="300" value="100" class="control-slider">
                            </div>
                            <div class="control-group">
                                <label class="control-label">Link Dist <span id="linkdist-value" class="control-value">100%</span></label>
                                <input type="range" id="linkdist-slider" min="30" max="200" value="100" class="control-slider">
                            </div>
                            <div class="control-group">
                                <label class="control-label">Link Pull <span id="linkstrength-value" class="control-value">100%</span></label>
                                <input type="range" id="linkstrength-slider" min="10" max="200" value="100" class="control-slider">
                            </div>
                        </div>
                        <div class="control-row">
                            <label class="control-checkbox">
                                <input type="checkbox" id="cluster-sector">
                                <span>Cluster by sector</span>
                            </label>
                            <label class="control-checkbox">
                                <input type="checkbox" id="show-labels" checked>
                                <span>Show labels</span>
                            </label>
                            <button id="reset-controls" class="reset-btn">Reset</button>
                            <button id="fullscreen-btn" class="fullscreen-btn" title="Fullscreen"><span class="fs-open">‚õ∂</span><span class="fs-close">‚úï</span></button>
                        </div>
                    </div>
                    
                    <div id="network-chart">
                        <div class="chart-hint">Drag nodes ‚Ä¢ Scroll to zoom ‚Ä¢ Hover for details ‚Ä¢ Double-click to focus</div>
                    </div>
                    <div id="chord-chart" style="display:none;"></div>
                </div>

                <div class="sidebar-card circularity-sidebar">
                    <div class="sidebar-title">Sector Details</div>
                    <div id="sector-details">
                        <div class="empty-state" style="padding:30px 10px;">
                            <div class="empty-state-text" style="font-size:0.8rem;">Hover over a sector</div>
                            <div class="empty-state-hint">to see flow details</div>
                        </div>
                    </div>

                    <div class="sidebar-title" style="margin-top:24px;">Top Flows</div>
                    <div id="top-flows-list" class="top-flows-list"></div>
                </div>
            </div>

            <div class="explanation-section">
                <div class="explanation-title">Understanding Material & Waste Flows</div>
                <div class="explanation-grid">
                    <div class="explanation-card">
                        <h4>What does this show?</h4>
                        <p><strong>Dollar Flows</strong> show the value of intermediate goods traded between sectors. <strong>Waste Flows</strong> show waste generated when one sector supplies another.</p>
                        <p style="margin-top:8px">Line thickness indicates flow magnitude. Arrows show direction: from supplier to customer (dollars) or from waste source to economic demand driver (waste).</p>
                    </div>
                    <div class="explanation-card">
                        <h4>Waste Categories</h4>
                        <p><strong>MSW</strong> (Municipal Solid Waste): Paper, plastics, food scraps, yard waste from commercial/institutional sources.</p>
                        <p style="margin-top:8px"><strong>CDD</strong> (Construction & Demolition): Concrete, wood, asphalt, metals from building projects. <strong>Hazardous</strong>: Toxic chemicals, solvents, heavy metals.</p>
                    </div>
                    <div class="explanation-card">
                        <h4>Circularity Potential</h4>
                        <p>Compare dollar flows with waste flows to identify <strong>circular economy opportunities</strong>. Where waste flows are high relative to dollar flows, there's potential for waste-to-resource conversion.</p>
                        <p style="margin-top:8px">Look for sectors that both generate and could potentially use similar waste streams.</p>
                    </div>
                    <div class="explanation-card">
                        <h4>Data Source</h4>
                        <p>From USEEIO v2.0.1: Dollar flows use the <strong>Direct Requirements Matrix</strong>. Waste flows use <strong>Satellite Accounts (B matrix)</strong> tracking waste per dollar of production.</p>
                        <p style="margin-top:8px">411 industries aggregated into 20 NAICS sectors. Waste = B coefficient √ó A coefficient √ó industry output.</p>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // Data
        let linkagesData = [];
        let shockData = [];
        let L_sparse = {};
        let A_sparse = {};
        let selectedDemandIndustry = null;
        let selectedCostIndustry = null;
        let selectedChartIndustry = null;
        let chartElements = null;

        // Circularity data
        let circularityData = null;
        let chordElements = null;
        let selectedChordSector = null;

        // Load data
        Promise.all([
            fetch('linkages_data.json').then(r => r.json()),
            fetch('shock_data.json').then(r => r.json()),
            fetch('circularity_data.json').then(r => r.json())
        ]).then(([linkages, shock, circularity]) => {
            linkagesData = linkages.industries;
            circularityData = circularity;
            
            const linkagesMap = {};
            linkagesData.forEach(d => linkagesMap[d.id] = d);
            
            shockData = shock.industries.map(d => ({
                ...d,
                bl: linkagesMap[d.id]?.bl || 1,
                fl: linkagesMap[d.id]?.fl || 1,
                isKey: linkagesMap[d.id]?.isKey || false
            }));
            
            L_sparse = shock.L_sparse || {};
            A_sparse = shock.A_sparse || {};
            
            initLinkagesPage();
            initShockPage();
            initCircularityPage();
            updateStats();
        });

        // Navigation
        document.querySelectorAll('.nav-tab').forEach(tab => {
            tab.addEventListener('click', () => {
                document.querySelectorAll('.nav-tab').forEach(t => t.classList.remove('active'));
                document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
                tab.classList.add('active');
                document.getElementById(`page-${tab.dataset.page}`).classList.add('active');
                
                // Initialize chart when circularity tab is clicked
                if (tab.dataset.page === 'circularity' && circularityData) {
                    setTimeout(() => {
                        if (currentCircView === 'network' && !networkElements) {
                            createNetworkChart();
                        } else if (currentCircView === 'chord' && !chordElements) {
                            createChordDiagram();
                        }
                        renderTopFlows();
                    }, 50);
                }
            });
        });

        // =============== LINKAGES PAGE ===============
        function initLinkagesPage() {
            createQuadrantChart();
            renderIndustryList();
            
            document.getElementById('linkage-search').addEventListener('input', (e) => {
                renderIndustryList(e.target.value);
            });
        }

        function updateStats() {
            const keySectors = linkagesData.filter(d => d.isKey).length;
            const avgBL = linkagesData.reduce((s, d) => s + d.bl, 0) / linkagesData.length;
            const avgFL = linkagesData.reduce((s, d) => s + d.fl, 0) / linkagesData.length;
            
            document.getElementById('stat-total').textContent = linkagesData.length;
            document.getElementById('stat-key').textContent = keySectors;
            document.getElementById('stat-bl').textContent = avgBL.toFixed(2);
            document.getElementById('stat-fl').textContent = avgFL.toFixed(2);
        }

        function getColor(d) {
            if (d.bl > 1 && d.fl > 1) return '#16a34a';
            if (d.fl > 1) return '#ea580c';
            if (d.bl > 1) return '#2563eb';
            return '#9ca3af';
        }

        function createQuadrantChart() {
            const container = document.getElementById('quadrant-chart');
            const width = container.clientWidth;
            const height = 480;
            const margin = { top: 30, right: 30, bottom: 50, left: 60 };

            const svg = d3.select('#quadrant-chart')
                .append('svg')
                .attr('width', width)
                .attr('height', height);

            const xExtent = d3.extent(linkagesData, d => d.bl);
            const yExtent = d3.extent(linkagesData, d => d.fl);
            const padding = 0.1;

            const xScale = d3.scaleLinear()
                .domain([Math.min(xExtent[0], 0.5) - padding, Math.max(xExtent[1], 2) + padding])
                .range([margin.left, width - margin.right]);

            const yScale = d3.scaleLinear()
                .domain([Math.min(yExtent[0], 0.5) - padding, Math.max(yExtent[1], 3) + padding])
                .range([height - margin.bottom, margin.top]);

            const sizeScale = d3.scaleSqrt()
                .domain([0, d3.max(linkagesData, d => d.output)])
                .range([3, 18]);

            // Reference lines at 1
            svg.append('line')
                .attr('x1', xScale(1)).attr('x2', xScale(1))
                .attr('y1', margin.top).attr('y2', height - margin.bottom)
                .attr('stroke', '#e5e5e5').attr('stroke-width', 1);

            svg.append('line')
                .attr('x1', margin.left).attr('x2', width - margin.right)
                .attr('y1', yScale(1)).attr('y2', yScale(1))
                .attr('stroke', '#e5e5e5').attr('stroke-width', 1);

            // Quadrant labels
            svg.append('text').attr('x', xScale(1.5)).attr('y', yScale(2.2)).attr('text-anchor', 'middle')
                .attr('fill', '#16a34a').attr('font-size', '0.65rem').attr('font-weight', '600').text('KEY');
            svg.append('text').attr('x', xScale(0.7)).attr('y', yScale(2.2)).attr('text-anchor', 'middle')
                .attr('fill', '#ea580c').attr('font-size', '0.65rem').attr('font-weight', '600').text('FORWARD');
            svg.append('text').attr('x', xScale(1.5)).attr('y', yScale(0.7)).attr('text-anchor', 'middle')
                .attr('fill', '#2563eb').attr('font-size', '0.65rem').attr('font-weight', '600').text('BACKWARD');
            svg.append('text').attr('x', xScale(0.7)).attr('y', yScale(0.7)).attr('text-anchor', 'middle')
                .attr('fill', '#9ca3af').attr('font-size', '0.65rem').attr('font-weight', '600').text('WEAK');

            // Axes
            svg.append('g')
                .attr('transform', `translate(0,${height - margin.bottom})`)
                .call(d3.axisBottom(xScale).ticks(6))
                .call(g => g.select('.domain').attr('stroke', '#e5e5e5'))
                .call(g => g.selectAll('.tick line').attr('stroke', '#e5e5e5'))
                .call(g => g.selectAll('.tick text').attr('fill', '#666').attr('font-size', '0.7rem'));

            svg.append('g')
                .attr('transform', `translate(${margin.left},0)`)
                .call(d3.axisLeft(yScale).ticks(6))
                .call(g => g.select('.domain').attr('stroke', '#e5e5e5'))
                .call(g => g.selectAll('.tick line').attr('stroke', '#e5e5e5'))
                .call(g => g.selectAll('.tick text').attr('fill', '#666').attr('font-size', '0.7rem'));

            // Axis labels
            svg.append('text')
                .attr('x', width / 2)
                .attr('y', height - 8)
                .attr('text-anchor', 'middle')
                .attr('fill', '#666')
                .attr('font-size', '0.75rem')
                .attr('font-weight', '500')
                .text('‚Üê Less buying | Backward Linkage | More buying ‚Üí');

            svg.append('text')
                .attr('transform', 'rotate(-90)')
                .attr('x', -height / 2)
                .attr('y', 14)
                .attr('text-anchor', 'middle')
                .attr('fill', '#666')
                .attr('font-size', '0.75rem')
                .attr('font-weight', '500')
                .text('‚Üê Less selling | Forward Linkage | More selling ‚Üí');

            // Dots
            const tooltip = document.getElementById('tooltip');

            const dots = svg.selectAll('circle')
                .data(linkagesData)
                .enter()
                .append('circle')
                .attr('cx', d => xScale(d.bl))
                .attr('cy', d => yScale(d.fl))
                .attr('r', d => sizeScale(d.output))
                .attr('fill', d => getColor(d))
                .attr('fill-opacity', 0.7)
                .attr('stroke', d => getColor(d))
                .attr('stroke-width', 1)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    if (!selectedChartIndustry) {
                        d3.select(this).attr('fill-opacity', 1).attr('stroke-width', 2);
                    }
                    showTooltip(event, d);
                })
                .on('mousemove', function(event) {
                    tooltip.style.left = (event.clientX + 12) + 'px';
                    tooltip.style.top = (event.clientY + 12) + 'px';
                })
                .on('mouseout', function(event, d) {
                    if (!selectedChartIndustry || selectedChartIndustry.id !== d.id) {
                        d3.select(this).attr('fill-opacity', selectedChartIndustry ? 0.1 : 0.7).attr('stroke-width', 1);
                    }
                    tooltip.classList.remove('visible');
                })
                .on('click', function(event, d) {
                    selectIndustryOnChart(d);
                });

            chartElements = { svg, dots, xScale, yScale, sizeScale };
        }

        function showTooltip(event, d) {
            const tooltip = document.getElementById('tooltip');
            tooltip.innerHTML = `
                <div class="tooltip-title">${d.name}</div>
                <div class="tooltip-row"><span class="tooltip-label">Sector</span><span class="tooltip-value">${d.sector}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">Output</span><span class="tooltip-value">$${d.output.toFixed(1)}B</span></div>
                <div class="tooltip-row"><span class="tooltip-label">Backward linkage</span><span class="tooltip-value" style="color:#2563eb">${d.bl.toFixed(3)}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">Forward linkage</span><span class="tooltip-value" style="color:#ea580c">${d.fl.toFixed(3)}</span></div>
                ${d.isKey ? '<div style="margin-top:8px;color:#16a34a;font-weight:600">‚òÖ Key Sector</div>' : ''}
            `;
            tooltip.classList.add('visible');
        }

        function selectIndustryOnChart(d) {
            selectedChartIndustry = d;
            document.getElementById('clear-selection').classList.add('visible');
            
            chartElements.dots
                .attr('fill-opacity', node => node.id === d.id ? 1 : 0.1)
                .attr('stroke-width', node => node.id === d.id ? 3 : 1)
                .attr('stroke', node => node.id === d.id ? '#1a1a1a' : getColor(node));

            // Highlight in list
            document.querySelectorAll('.industry-item').forEach(item => {
                item.classList.toggle('selected', item.dataset.id === d.id);
            });
        }

        function clearSelection() {
            selectedChartIndustry = null;
            document.getElementById('clear-selection').classList.remove('visible');
            
            chartElements.dots
                .attr('fill-opacity', 0.7)
                .attr('stroke-width', 1)
                .attr('stroke', d => getColor(d));

            document.querySelectorAll('.industry-item').forEach(item => {
                item.classList.remove('selected');
            });
        }

        function renderIndustryList(filter = '') {
            const list = document.getElementById('industry-list');
            const filtered = linkagesData
                .filter(d => d.name.toLowerCase().includes(filter.toLowerCase()))
                .sort((a, b) => b.output - a.output)
                .slice(0, 40);

            list.innerHTML = filtered.map(d => {
                let cls = '';
                if (d.isKey) cls = 'key-sector';
                else if (d.fl > 1) cls = 'forward-oriented';
                else if (d.bl > 1) cls = 'backward-oriented';
                
                const isSelected = selectedChartIndustry && selectedChartIndustry.id === d.id;
                
                return `
                    <div class="industry-item ${cls} ${isSelected ? 'selected' : ''}" data-id="${d.id}">
                        <div class="industry-name">${d.name}</div>
                        <div class="industry-metrics">
                            <span>BL ${d.bl.toFixed(2)}</span>
                            <span>FL ${d.fl.toFixed(2)}</span>
                            <span>$${d.output.toFixed(0)}B</span>
                        </div>
                    </div>
                `;
            }).join('');

            list.querySelectorAll('.industry-item').forEach(item => {
                item.addEventListener('click', () => {
                    const d = linkagesData.find(x => x.id === item.dataset.id);
                    if (d) selectIndustryOnChart(d);
                });
            });
        }

        // =============== SHOCK ANALYSIS PAGE ===============
        function initShockPage() {
            populateShockList('list-demand', 'search-demand', (d) => {
                selectedDemandIndustry = d;
                document.getElementById('run-demand').disabled = false;
            });
            populateShockList('list-cost', 'search-cost', (d) => {
                selectedCostIndustry = d;
                document.getElementById('run-cost').disabled = false;
            });

            document.querySelectorAll('.shock-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.shock-tab').forEach(t => t.classList.remove('active'));
                    document.querySelectorAll('.shock-panel').forEach(p => p.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById(`panel-${tab.dataset.tab}`).classList.add('active');
                });
            });

            document.getElementById('demand-slider').addEventListener('input', (e) => {
                const val = parseFloat(e.target.value);
                document.getElementById('demand-value').textContent = (val >= 0 ? '+' : '') + `$${val}B`;
            });

            document.getElementById('cost-slider').addEventListener('input', (e) => {
                document.getElementById('cost-value').textContent = `+${e.target.value}%`;
            });

            document.getElementById('risk-threshold').addEventListener('input', (e) => {
                const labels = ['All', 'Medium+', 'High only'];
                document.getElementById('risk-threshold-value').textContent = labels[e.target.value - 1];
            });

            document.getElementById('run-demand').addEventListener('click', runDemandShock);
            document.getElementById('run-cost').addEventListener('click', runCostShock);
            document.getElementById('run-risk').addEventListener('click', runRiskAnalysis);
            document.getElementById('clear-demand').addEventListener('click', clearShockResults);
            document.getElementById('clear-cost').addEventListener('click', clearShockResults);
        }

        function populateShockList(listId, searchId, onSelect) {
            const list = document.getElementById(listId);
            const search = document.getElementById(searchId);
            
            function render(filter = '') {
                const filtered = shockData
                    .filter(d => d.name.toLowerCase().includes(filter.toLowerCase()))
                    .sort((a, b) => b.output - a.output)
                    .slice(0, 30);
                
                list.innerHTML = filtered.map(d => `
                    <div class="shock-industry-item" data-id="${d.id}">
                        <div class="shock-industry-name">${d.name}</div>
                        <div class="shock-industry-meta">${d.sector} ¬∑ $${d.output.toFixed(1)}B ¬∑ ${d.outputMultiplier.toFixed(2)}x</div>
                    </div>
                `).join('');
                
                list.querySelectorAll('.shock-industry-item').forEach(item => {
                    item.addEventListener('click', () => {
                        const d = shockData.find(x => x.id === item.dataset.id);
                        onSelect(d);
                        list.querySelectorAll('.shock-industry-item').forEach(i => i.classList.remove('selected'));
                        item.classList.add('selected');
                    });
                });
            }
            
            render();
            search.addEventListener('input', (e) => render(e.target.value));
        }

        function clearShockResults() {
            document.getElementById('results-container').innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-text">No analysis running</div>
                    <div class="empty-state-hint">Choose settings in the left panel and click a button to start</div>
                </div>
            `;
            document.getElementById('results-title').textContent = 'Results';
            document.getElementById('results-subtitle').textContent = 'Select an industry and run analysis';
        }

        function runDemandShock() {
            if (!selectedDemandIndustry) return;
            
            const shock = parseFloat(document.getElementById('demand-slider').value);
            const d = selectedDemandIndustry;
            
            const impacts = [];
            const L_col = L_sparse[d.id] || {};
            const totalOutputImpact = shock * d.outputMultiplier;
            
            Object.entries(L_col).forEach(([targetId, multiplier]) => {
                const target = shockData.find(x => x.id === targetId);
                if (target && targetId !== d.id) {
                    impacts.push({
                        id: targetId,
                        name: target.name,
                        sector: target.sector,
                        impact: shock * multiplier,
                        pctOfOutput: (shock * multiplier / target.output) * 100
                    });
                }
            });
            
            impacts.sort((a, b) => Math.abs(b.impact) - Math.abs(a.impact));
            
            document.getElementById('results-title').textContent = `Demand Shock: ${d.name}`;
            document.getElementById('results-subtitle').textContent = `${shock >= 0 ? '+' : ''}$${shock}B change in final demand`;
            
            const maxImpact = Math.max(...impacts.map(x => Math.abs(x.impact)), 0.01);
            
            document.getElementById('results-container').innerHTML = `
                <div class="metrics-row">
                    <div class="metric-card">
                        <div class="metric-label">Direct change</div>
                        <div class="metric-value ${shock >= 0 ? 'positive' : 'negative'}">${shock >= 0 ? '+' : ''}$${shock}B</div>
                        <div class="metric-detail">Applied to ${d.name.substring(0, 25)}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Total economy impact</div>
                        <div class="metric-value ${shock >= 0 ? 'positive' : 'negative'}">${shock >= 0 ? '+' : ''}$${totalOutputImpact.toFixed(1)}B</div>
                        <div class="metric-detail">Multiplier: ${d.outputMultiplier.toFixed(2)}x</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Industries affected</div>
                        <div class="metric-value">${impacts.length}</div>
                        <div class="metric-detail">Through supply chain</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Backward linkage</div>
                        <div class="metric-value">${d.bl?.toFixed(2) || '‚Äî'}</div>
                        <div class="metric-detail">${(d.bl || 0) > 1 ? 'Above' : 'Below'} average</div>
                    </div>
                </div>

                <div class="results-card">
                    <div class="results-card-title">Supplier industries affected</div>
                    <div class="results-card-subtitle">Industries that supply inputs ‚Äî their output changes when demand for ${d.name.substring(0, 30)} changes</div>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th style="width: 40%">Industry</th>
                                <th style="width: 15%">Sector</th>
                                <th style="width: 15%">Impact</th>
                                <th style="width: 12%">% of output</th>
                                <th style="width: 18%">Scale</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${impacts.slice(0, 20).map(imp => `
                                <tr>
                                    <td><strong>${imp.name.substring(0, 40)}</strong></td>
                                    <td style="color: #666; font-size: 0.7rem;">${imp.sector}</td>
                                    <td style="font-family: 'IBM Plex Mono'; font-size: 0.75rem; color: ${imp.impact >= 0 ? '#16a34a' : '#dc2626'}">
                                        ${imp.impact >= 0 ? '+' : ''}$${imp.impact.toFixed(2)}B
                                    </td>
                                    <td style="font-family: 'IBM Plex Mono'; font-size: 0.75rem; color: #666;">
                                        ${Math.abs(imp.pctOfOutput).toFixed(2)}%
                                    </td>
                                    <td>
                                        <div class="bar-cell">
                                            <div class="bar-fill blue" style="width: ${(Math.abs(imp.impact) / maxImpact * 100)}%"></div>
                                        </div>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function runCostShock() {
            if (!selectedCostIndustry) return;
            
            const costIncrease = parseFloat(document.getElementById('cost-slider').value) / 100;
            const d = selectedCostIndustry;
            
            const costImpacts = [];
            const A_row = A_sparse[d.id] || {};
            
            Object.entries(A_row).forEach(([customerId, inputShare]) => {
                const customer = shockData.find(x => x.id === customerId);
                if (customer) {
                    costImpacts.push({
                        id: customerId,
                        name: customer.name,
                        sector: customer.sector,
                        inputShare: inputShare * 100,
                        costPush: inputShare * costIncrease * 100,
                        output: customer.output
                    });
                }
            });
            
            costImpacts.sort((a, b) => b.costPush - a.costPush);
            const totalExposure = costImpacts.reduce((sum, x) => sum + x.costPush * x.output / 100, 0);
            
            document.getElementById('results-title').textContent = `Cost Shock: ${d.name}`;
            document.getElementById('results-subtitle').textContent = `+${(costIncrease * 100).toFixed(0)}% price increase`;
            
            const maxCost = Math.max(...costImpacts.map(x => x.costPush), 0.01);
            
            document.getElementById('results-container').innerHTML = `
                <div class="metrics-row">
                    <div class="metric-card">
                        <div class="metric-label">Price increase</div>
                        <div class="metric-value negative">+${(costIncrease * 100).toFixed(0)}%</div>
                        <div class="metric-detail">In ${d.name.substring(0, 25)}</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Downstream industries</div>
                        <div class="metric-value">${costImpacts.length}</div>
                        <div class="metric-detail">Directly exposed</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Total cost exposure</div>
                        <div class="metric-value negative">$${totalExposure.toFixed(1)}B</div>
                        <div class="metric-detail">Potential margin impact</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Forward linkage</div>
                        <div class="metric-value">${d.fl?.toFixed(2) || '‚Äî'}</div>
                        <div class="metric-detail">${(d.fl || 0) > 1 ? 'Major supplier' : 'Limited reach'}</div>
                    </div>
                </div>

                <div class="results-card">
                    <div class="results-card-title">Downstream cost exposure</div>
                    <div class="results-card-subtitle">Industries that buy from ${d.name.substring(0, 35)} ‚Äî shows how their costs increase</div>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th style="width: 40%">Customer industry</th>
                                <th style="width: 15%">Sector</th>
                                <th style="width: 15%">Input share</th>
                                <th style="width: 12%">Cost push</th>
                                <th style="width: 18%">Exposure</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${costImpacts.slice(0, 25).map(imp => `
                                <tr>
                                    <td><strong>${imp.name.substring(0, 40)}</strong></td>
                                    <td style="color: #666; font-size: 0.7rem;">${imp.sector}</td>
                                    <td style="font-family: 'IBM Plex Mono'; font-size: 0.75rem;">${imp.inputShare.toFixed(1)}%</td>
                                    <td style="font-family: 'IBM Plex Mono'; font-size: 0.75rem; color: #dc2626;">+${imp.costPush.toFixed(2)}%</td>
                                    <td>
                                        <div class="bar-cell">
                                            <div class="bar-fill red" style="width: ${(imp.costPush / maxCost * 100)}%"></div>
                                        </div>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                    </table>
                </div>
            `;
        }

        function runRiskAnalysis() {
            const threshold = parseInt(document.getElementById('risk-threshold').value);
            
            const riskScores = shockData.map(d => {
                const concentrationRisk = (d.inputConcentration || 0) / 100;
                const dependencyRisk = (d.totalInputShare || 0) / 100;
                const pricingPowerRisk = (d.fl || 1) < 1 ? (1 - (d.fl || 1)) : 0;
                
                const riskScore = (concentrationRisk * 0.4 + dependencyRisk * 0.4 + pricingPowerRisk * 0.2) * 100;
                
                let riskLevel = 'low';
                if (riskScore > 30) riskLevel = 'medium';
                if (riskScore > 50) riskLevel = 'high';
                
                return { ...d, riskScore, riskLevel, concentrationRisk: concentrationRisk * 100, dependencyRisk: dependencyRisk * 100 };
            });
            
            const levels = threshold === 3 ? ['high'] : threshold === 2 ? ['high', 'medium'] : ['high', 'medium', 'low'];
            const filtered = riskScores.filter(d => levels.includes(d.riskLevel));
            filtered.sort((a, b) => b.riskScore - a.riskScore);
            
            const highRisk = riskScores.filter(d => d.riskLevel === 'high').length;
            const medRisk = riskScores.filter(d => d.riskLevel === 'medium').length;
            const lowRisk = riskScores.filter(d => d.riskLevel === 'low').length;
            
            document.getElementById('results-title').textContent = 'Supply Chain Risk';
            document.getElementById('results-subtitle').textContent = `${filtered.length} industries shown`;
            
            document.getElementById('results-container').innerHTML = `
                <div class="metrics-row">
                    <div class="metric-card">
                        <div class="metric-label">High risk</div>
                        <div class="metric-value negative">${highRisk}</div>
                        <div class="metric-detail">Concentrated, dependent</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Medium risk</div>
                        <div class="metric-value" style="color:#ea580c">${medRisk}</div>
                        <div class="metric-detail">Moderate exposure</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Low risk</div>
                        <div class="metric-value positive">${lowRisk}</div>
                        <div class="metric-detail">Diversified inputs</div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">Avg risk score</div>
                        <div class="metric-value">${(riskScores.reduce((s, x) => s + x.riskScore, 0) / riskScores.length).toFixed(1)}</div>
                        <div class="metric-detail">Economy-wide</div>
                    </div>
                </div>

                <div class="results-card">
                    <div class="results-card-title">Margin risk assessment</div>
                    <div class="results-card-subtitle">Risk = Input concentration (40%) + Input dependency (40%) + Limited pricing power (20%)</div>
                    <table class="data-table">
                        <thead>
                            <tr>
                                <th style="width: 32%">Industry</th>
                                <th style="width: 10%">Risk</th>
                                <th style="width: 10%">Score</th>
                                <th style="width: 12%">Concentration</th>
                                <th style="width: 12%">Dependency</th>
                                <th style="width: 8%">FL</th>
                                <th style="width: 16%">Scale</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${filtered.slice(0, 30).map(d => `
                                <tr>
                                    <td><strong>${d.name.substring(0, 30)}</strong></td>
                                    <td><span class="risk-badge ${d.riskLevel}">${d.riskLevel}</span></td>
                                    <td style="font-family: 'IBM Plex Mono'; font-size: 0.75rem;">${d.riskScore.toFixed(1)}</td>
                                    <td style="font-family: 'IBM Plex Mono'; font-size: 0.75rem; color: #666;">${d.concentrationRisk.toFixed(1)}%</td>
                                    <td style="font-family: 'IBM Plex Mono'; font-size: 0.75rem; color: #666;">${d.dependencyRisk.toFixed(1)}%</td>
                                    <td style="font-family: 'IBM Plex Mono'; font-size: 0.75rem; color: ${(d.fl || 0) > 1 ? '#16a34a' : '#666'};">${d.fl?.toFixed(2) || '‚Äî'}</td>
                                    <td>
                                        <div class="bar-cell">
                                            <div class="bar-fill orange" style="width: ${d.riskScore}%"></div>
                                        </div>
                                    </td>
                                </tr>
                            `).join('')}
                        </tbody>
                            </table>
                </div>
            `;
        }

        // =============== CIRCULARITY PAGE ===============
        let currentCircView = 'network';
        let currentFlowType = 'dollars';
        let networkElements = null;

        // Network parameters
        const networkParams = {
            layout: 'force',
            sectors: 20,
            threshold: 10,
            minLinks: 0,
            nodeSize: 100,
            charge: 100,
            linkDist: 100,
            linkStrength: 100,
            clusterBySector: false,
            showLabels: true
        };

        const flowTypeConfig = {
            'dollars': {
                name: 'Dollar Flows',
                unit: 'Billion USD',
                unitShort: 'B',
                prefix: '$',
                minFlow: 50,
                decimals: 0,
                color: '#3b82f6'
            },
            'MSW': {
                name: 'Municipal Solid Waste',
                unit: 'Million Metric Tons',
                unitShort: 'Mt',
                prefix: '',
                minFlow: 0.5,
                decimals: 2,
                color: '#16a34a'
            },
            'CDD': {
                name: 'Construction & Demolition Debris',
                unit: 'Million Metric Tons',
                unitShort: 'Mt',
                prefix: '',
                minFlow: 0.5,
                decimals: 2,
                color: '#f59e0b'
            },
            'Hazardous': {
                name: 'Hazardous Waste',
                unit: 'Million Metric Tons',
                unitShort: 'Mt',
                prefix: '',
                minFlow: 0.1,
                decimals: 2,
                color: '#ef4444'
            }
        };

        function getCurrentFlowData() {
            if (!circularityData || !circularityData.flow_types) return null;
            return circularityData.flow_types[currentFlowType];
        }

        function updateChartSubtitle() {
            const config = flowTypeConfig[currentFlowType];
            const subtitle = document.getElementById('chart-subtitle-circ');
            if (subtitle && config) {
                subtitle.textContent = `Line thickness = ${config.unit.toLowerCase()} of ${currentFlowType === 'dollars' ? 'intermediate goods traded' : 'waste generated'} annually`;
            }
        }

        function initCircularityPage() {
            // Flow type selector
            document.getElementById('flow-type-select').addEventListener('change', (e) => {
                currentFlowType = e.target.value;
                updateChartSubtitle();
                updateThresholdDisplay();
                
                // Recreate chart with new flow type
                if (currentCircView === 'chord') {
                    chordElements = null;
                    createChordDiagram();
                } else {
                    networkElements = null;
                    createNetworkChart();
                }
                renderTopFlows();
            });

            // View toggle
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    currentCircView = btn.dataset.view;
                    
                    // Show/hide network controls
                    document.getElementById('network-controls').style.display = 
                        btn.dataset.view === 'network' ? 'flex' : 'none';
                    
                    if (currentCircView === 'network') {
                        document.getElementById('network-chart').style.display = 'flex';
                        document.getElementById('chord-chart').style.display = 'none';
                        if (!networkElements) createNetworkChart();
                    } else {
                        document.getElementById('network-chart').style.display = 'none';
                        document.getElementById('chord-chart').style.display = 'flex';
                        if (!chordElements) createChordDiagram();
                    }
                });
            });

            // Internal flows toggle
            document.getElementById('show-self-loops').addEventListener('change', (e) => {
                if (currentCircView === 'chord') {
                    chordElements = null;
                    createChordDiagram();
                } else {
                    networkElements = null;
                    createNetworkChart();
                }
            });

            // Network control sliders
            initNetworkControls();
        }

        function updateThresholdDisplay() {
            const config = flowTypeConfig[currentFlowType];
            const val = networkParams.threshold;
            let displayVal;
            if (currentFlowType === 'dollars') {
                displayVal = `$${val}B`;
            } else {
                // Scale threshold for waste (0-100 maps to 0-10 Mt)
                const scaledVal = (val / 100) * 10;
                displayVal = `${scaledVal.toFixed(1)}Mt`;
            }
            document.getElementById('threshold-value').textContent = displayVal;
        }

        function initNetworkControls() {
            const rebuildChart = () => {
                networkElements = null;
                createNetworkChart();
            };

            // Layout select
            document.getElementById('layout-select').addEventListener('change', (e) => {
                networkParams.layout = e.target.value;
                rebuildChart();
            });

            // Sectors slider
            const sectorsSlider = document.getElementById('sectors-slider');
            sectorsSlider.addEventListener('input', (e) => {
                networkParams.sectors = parseInt(e.target.value);
                document.getElementById('sectors-value').textContent = networkParams.sectors;
            });
            sectorsSlider.addEventListener('change', rebuildChart);

            // Threshold slider
            const thresholdSlider = document.getElementById('threshold-slider');
            thresholdSlider.addEventListener('input', (e) => {
                networkParams.threshold = parseInt(e.target.value);
                updateThresholdDisplay();
            });
            thresholdSlider.addEventListener('change', rebuildChart);

            // Min links slider
            const minlinksSlider = document.getElementById('minlinks-slider');
            minlinksSlider.addEventListener('input', (e) => {
                networkParams.minLinks = parseInt(e.target.value);
                document.getElementById('minlinks-value').textContent = networkParams.minLinks;
            });
            minlinksSlider.addEventListener('change', rebuildChart);

            // Node size slider
            const nodesizeSlider = document.getElementById('nodesize-slider');
            nodesizeSlider.addEventListener('input', (e) => {
                networkParams.nodeSize = parseInt(e.target.value);
                document.getElementById('nodesize-value').textContent = networkParams.nodeSize + '%';
            });
            nodesizeSlider.addEventListener('change', rebuildChart);

            // Charge/repulsion slider
            const chargeSlider = document.getElementById('charge-slider');
            chargeSlider.addEventListener('input', (e) => {
                networkParams.charge = parseInt(e.target.value);
                document.getElementById('charge-value').textContent = networkParams.charge + '%';
            });
            chargeSlider.addEventListener('change', rebuildChart);

            // Link distance slider
            const linkdistSlider = document.getElementById('linkdist-slider');
            linkdistSlider.addEventListener('input', (e) => {
                networkParams.linkDist = parseInt(e.target.value);
                document.getElementById('linkdist-value').textContent = networkParams.linkDist + '%';
            });
            linkdistSlider.addEventListener('change', rebuildChart);

            // Link strength slider
            const linkstrengthSlider = document.getElementById('linkstrength-slider');
            linkstrengthSlider.addEventListener('input', (e) => {
                networkParams.linkStrength = parseInt(e.target.value);
                document.getElementById('linkstrength-value').textContent = networkParams.linkStrength + '%';
            });
            linkstrengthSlider.addEventListener('change', rebuildChart);

            // Cluster by sector checkbox
            document.getElementById('cluster-sector').addEventListener('change', (e) => {
                networkParams.clusterBySector = e.target.checked;
                rebuildChart();
            });

            // Show labels checkbox
            document.getElementById('show-labels').addEventListener('change', (e) => {
                networkParams.showLabels = e.target.checked;
                rebuildChart();
            });

            // Reset button
            document.getElementById('reset-controls').addEventListener('click', () => {
                networkParams.layout = 'force';
                networkParams.sectors = 20;
                networkParams.threshold = 10;
                networkParams.minLinks = 0;
                networkParams.nodeSize = 100;
                networkParams.charge = 100;
                networkParams.linkDist = 100;
                networkParams.linkStrength = 100;
                networkParams.clusterBySector = false;
                networkParams.showLabels = true;

                document.getElementById('layout-select').value = 'force';
                document.getElementById('sectors-slider').value = 20;
                document.getElementById('threshold-slider').value = 10;
                document.getElementById('minlinks-slider').value = 0;
                document.getElementById('nodesize-slider').value = 100;
                document.getElementById('charge-slider').value = 100;
                document.getElementById('linkdist-slider').value = 100;
                document.getElementById('linkstrength-slider').value = 100;
                document.getElementById('cluster-sector').checked = false;
                document.getElementById('show-labels').checked = true;

                document.getElementById('sectors-value').textContent = '20';
                updateThresholdDisplay();
                document.getElementById('minlinks-value').textContent = '0';
                document.getElementById('nodesize-value').textContent = '100%';
                document.getElementById('charge-value').textContent = '100%';
                document.getElementById('linkdist-value').textContent = '100%';
                document.getElementById('linkstrength-value').textContent = '100%';

                rebuildChart();
            });

            // Fullscreen button
            document.getElementById('fullscreen-btn').addEventListener('click', () => {
                const chartCard = document.querySelector('#page-circularity .chart-card');
                chartCard.classList.toggle('fullscreen');
                rebuildChart();
            });

            // ESC key to exit fullscreen
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    const chartCard = document.querySelector('#page-circularity .chart-card');
                    if (chartCard.classList.contains('fullscreen')) {
                        chartCard.classList.remove('fullscreen');
                        rebuildChart();
                    }
                }
            });

            // Initial display update
            updateThresholdDisplay();
        }

        function createNetworkChart() {
            const container = document.getElementById('network-chart');
            if (!container || !circularityData) return;
            
            const flowData = getCurrentFlowData();
            if (!flowData) return;
            
            container.innerHTML = '';
            
            const showSelfLoops = document.getElementById('show-self-loops')?.checked ?? false;
            const isFullscreen = document.querySelector('#page-circularity .chart-card')?.classList.contains('fullscreen');
            const containerWidth = container.clientWidth || 900;
            const containerHeight = container.clientHeight || 650;
            const width = containerWidth;
            const height = isFullscreen ? Math.max(containerHeight, window.innerHeight - 200) : 650;

            if (width < 100) return;

            const allIndustries = circularityData.industries || circularityData.sectors;
            const topFlows = flowData.top_flows || [];
            const config = flowTypeConfig[currentFlowType];

            // Calculate total flow per industry from sparse flow data
            const industryFlows = new Map();
            topFlows.forEach(f => {
                industryFlows.set(f.from, (industryFlows.get(f.from) || 0) + f.value);
                industryFlows.set(f.to, (industryFlows.get(f.to) || 0) + f.value);
            });

            // Sort industries by flow involvement (or output if no flows)
            const rankedIndustries = allIndustries.map((ind, i) => ({
                ...ind,
                index: i,
                totalFlow: industryFlows.get(i) || 0,
                output: ind.output || (circularityData.sector_info?.[ind]?.output) || 0
            }));
            rankedIndustries.sort((a, b) => b.totalFlow - a.totalFlow || b.output - a.output);

            // Take top N industries
            const topIndustries = rankedIndustries.slice(0, networkParams.sectors);
            const selectedIndices = new Set(topIndustries.map(ind => ind.index));
            const indexMap = new Map();
            topIndustries.forEach((ind, newIdx) => indexMap.set(ind.index, newIdx));

            // Calculate threshold based on slider
            let minFlow;
            if (currentFlowType === 'dollars') {
                minFlow = networkParams.threshold; // 0-100 = $0B-$100B
            } else {
                minFlow = (networkParams.threshold / 100) * 10; // 0-100 = 0-10 Mt
            }

            // Create nodes
            const nodes = topIndustries.map((ind, newIdx) => {
                const name = ind.name || ind;
                return {
                    id: newIdx,
                    originalIndex: ind.index,
                    name: name,
                    shortName: name.length > 18 ? name.substring(0, 16) + '‚Ä¶' : name,
                    sector: ind.sector || 'Other',
                    output: ind.output,
                    inflow: 0,
                    outflow: 0
                };
            });

            // Create links from sparse flow data
            const tempLinks = [];
            const connectionCount = new Map();
            
            topFlows.forEach(f => {
                if (!selectedIndices.has(f.from) || !selectedIndices.has(f.to)) return;
                if (!showSelfLoops && f.from === f.to) return;
                if (f.value < minFlow) return;
                
                const srcIdx = indexMap.get(f.from);
                const tgtIdx = indexMap.get(f.to);
                
                nodes[srcIdx].outflow += f.value;
                nodes[tgtIdx].inflow += f.value;
                
                connectionCount.set(srcIdx, (connectionCount.get(srcIdx) || 0) + 1);
                connectionCount.set(tgtIdx, (connectionCount.get(tgtIdx) || 0) + 1);
                
                tempLinks.push({
                    source: srcIdx,
                    target: tgtIdx,
                    value: f.value,
                    isSelf: f.from === f.to
                });
            });

            // Filter nodes by minimum connections
            const minLinks = networkParams.minLinks;
            const validNodes = new Set();
            nodes.forEach((n, i) => {
                if ((connectionCount.get(i) || 0) >= minLinks) {
                    validNodes.add(i);
                }
            });

            // Re-map node indices after filtering
            const finalNodes = [];
            const finalIndexMap = new Map();
            nodes.forEach((n, i) => {
                if (validNodes.has(i)) {
                    finalIndexMap.set(i, finalNodes.length);
                    finalNodes.push({ ...n, id: finalNodes.length });
                }
            });

            // Filter links to only include valid nodes
            const links = tempLinks.filter(l => 
                validNodes.has(l.source) && validNodes.has(l.target)
            ).map(l => ({
                ...l,
                source: finalIndexMap.get(l.source),
                target: finalIndexMap.get(l.target)
            }));

            // Use finalNodes instead of nodes
            const displayNodes = finalNodes;

            // Clean, minimal color - single accent color based on flow type
            const accentColor = config.color;
            const nodeColor = '#64748b';
            
            // Sector colors for clustering
            const sectorColors = d3.scaleOrdinal(d3.schemeTableau10);
            
            // Size scale - adjusted by nodeSize parameter
            const sizeMultiplier = networkParams.nodeSize / 100;
            const sizeScale = d3.scaleSqrt()
                .domain([0, d3.max(displayNodes, d => d.output) || 1])
                .range([10 * sizeMultiplier, 32 * sizeMultiplier]);

            // Link width scale
            const linkScale = d3.scaleSqrt()
                .domain([minFlow || 0.1, d3.max(links, d => d.value) || 600])
                .range([0.5, 3]);

            const svg = d3.select('#network-chart')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .style('background', '#fff')
                .style('border-radius', '4px')
                .style('overflow', 'hidden');

            // Add clip path to keep nodes inside bounds
            svg.append('defs')
                .append('clipPath')
                .attr('id', 'chart-clip')
                .append('rect')
                .attr('width', width)
                .attr('height', height);

            const defs = svg.append('defs');
            
            // Single small arrow marker
            defs.append('marker')
                .attr('id', 'arrow-small')
                .attr('viewBox', '-0 -3 6 6')
                .attr('refX', 18)
                .attr('refY', 0)
                .attr('orient', 'auto')
                .attr('markerWidth', 3)
                .attr('markerHeight', 3)
                .append('path')
                .attr('d', 'M 0,-2 L 4,0 L 0,2')
                .attr('fill', accentColor)
                .attr('fill-opacity', 0.4);

            // Create container for zoom with clipping
            const g = svg.append('g')
                .attr('clip-path', 'url(#chart-clip)');

            // Add zoom behavior with bounds
            const zoom = d3.zoom()
                .scaleExtent([0.5, 4])
                .translateExtent([[-100, -100], [width + 100, height + 100]])
                .on('zoom', (event) => g.attr('transform', event.transform));
            
            svg.call(zoom);

            // Layout parameters
            const chargeMultiplier = networkParams.charge / 100;
            const linkDistMultiplier = networkParams.linkDist / 100;
            const linkStrengthMultiplier = networkParams.linkStrength / 100;

            // Get unique sectors for clustering
            const sectors = [...new Set(displayNodes.map(n => n.sector))];
            const sectorCenters = {};
            const angleStep = (2 * Math.PI) / sectors.length;
            const clusterRadius = Math.min(width, height) * 0.3;
            sectors.forEach((s, i) => {
                sectorCenters[s] = {
                    x: width / 2 + clusterRadius * Math.cos(i * angleStep - Math.PI / 2),
                    y: height / 2 + clusterRadius * Math.sin(i * angleStep - Math.PI / 2)
                };
            });

            // Bounds for positions
            const boundsMargin = 60;
            const clampX = (x) => Math.max(boundsMargin, Math.min(width - boundsMargin, x));
            const clampY = (y) => Math.max(boundsMargin, Math.min(height - boundsMargin, y));

            // Apply initial positions based on layout
            if (networkParams.layout === 'radial') {
                // Radial layout - arrange by importance in concentric circles
                const sortedByOutput = [...displayNodes].sort((a, b) => b.output - a.output);
                const maxRingRadius = Math.min(width, height) / 2 - boundsMargin - 20;
                const nodesPerRing = Math.max(6, Math.floor(displayNodes.length / 5));
                
                sortedByOutput.forEach((n, i) => {
                    const ring = Math.floor(i / nodesPerRing);
                    const posInRing = i % nodesPerRing;
                    const totalRings = Math.ceil(displayNodes.length / nodesPerRing);
                    const ringRadius = Math.min(60 + ring * 50 * linkDistMultiplier, maxRingRadius);
                    const angle = (posInRing / nodesPerRing) * 2 * Math.PI - Math.PI / 2 + (ring * 0.3);
                    n.x = clampX(width / 2 + ringRadius * Math.cos(angle));
                    n.y = clampY(height / 2 + ringRadius * Math.sin(angle));
                    n.fx = n.x;
                    n.fy = n.y;
                });
            } else if (networkParams.layout === 'circular') {
                // Circular layout - all nodes on one circle
                const maxRadius = Math.min(width, height) / 2 - boundsMargin - 20;
                const radius = Math.min(maxRadius, Math.min(width, height) * 0.35 * linkDistMultiplier);
                
                displayNodes.forEach((n, i) => {
                    const angle = (i / displayNodes.length) * 2 * Math.PI - Math.PI / 2;
                    n.x = clampX(width / 2 + radius * Math.cos(angle));
                    n.y = clampY(height / 2 + radius * Math.sin(angle));
                    n.fx = n.x;
                    n.fy = n.y;
                });
            }

            // Initialize force layout positions within bounds
            if (networkParams.layout === 'force') {
                displayNodes.forEach((n, i) => {
                    // Start in a small circle around center
                    const angle = (i / displayNodes.length) * 2 * Math.PI;
                    const r = 50 + Math.random() * 50;
                    n.x = width / 2 + r * Math.cos(angle);
                    n.y = height / 2 + r * Math.sin(angle);
                });
            }

            // Create simulation
            const simulation = d3.forceSimulation(displayNodes);
            
            if (networkParams.layout === 'force') {
                simulation
                    .force('link', d3.forceLink(links).id(d => d.id)
                        .distance(100 * linkDistMultiplier)
                        .strength(0.3 * linkStrengthMultiplier))
                    .force('charge', d3.forceManyBody().strength(-600 * chargeMultiplier))
                    .force('center', d3.forceCenter(width / 2, height / 2))
                    .force('collision', d3.forceCollide().radius(d => sizeScale(d.output) + 10));

                // Add clustering force if enabled
                if (networkParams.clusterBySector) {
                    simulation.force('cluster', d3.forceX(d => sectorCenters[d.sector]?.x || width / 2).strength(0.15));
                    simulation.force('clusterY', d3.forceY(d => sectorCenters[d.sector]?.y || height / 2).strength(0.15));
                } else {
                    simulation.force('x', d3.forceX(width / 2).strength(0.05));
                    simulation.force('y', d3.forceY(height / 2).strength(0.05));
                }
            } else {
                // For radial/circular, just add link force for visual connection
                simulation.force('link', d3.forceLink(links).id(d => d.id).strength(0));
            }

            const tooltip = document.getElementById('tooltip');

            // Draw links as curved paths - clean, single color
            const link = g.append('g')
                .attr('class', 'links')
                .selectAll('path')
                .data(links)
                .enter()
                .append('path')
                .attr('fill', 'none')
                .attr('stroke', accentColor)
                .attr('stroke-opacity', 0.3)
                .attr('stroke-width', d => linkScale(d.value))
                .attr('stroke-linecap', 'round')
                .attr('marker-end', 'url(#arrow-small)')
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    d3.select(this).attr('stroke-opacity', 0.8).attr('stroke-width', linkScale(d.value) + 1);
                    const valueStr = config.prefix + d.value.toFixed(config.decimals) + config.unitShort;
                    const flowLabel = currentFlowType === 'dollars' ? 'Material Flow' : `${config.name} Flow`;
                    const srcNode = displayNodes[d.source.id ?? d.source];
                    const tgtNode = displayNodes[d.target.id ?? d.target];
                    tooltip.innerHTML = `
                        <div class="tooltip-title" style="font-size:0.9rem;">${flowLabel}</div>
                        <div class="tooltip-row"><span class="tooltip-label">From</span><span class="tooltip-value">${srcNode?.shortName || 'Unknown'}</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">To</span><span class="tooltip-value">${tgtNode?.shortName || 'Unknown'}</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">Value</span><span class="tooltip-value" style="color:${config.color};font-size:1rem;font-weight:700;">${valueStr}</span></div>
                    `;
                    tooltip.style.left = (event.clientX + 15) + 'px';
                    tooltip.style.top = (event.clientY + 15) + 'px';
                    tooltip.classList.add('visible');
                })
                .on('mouseout', function(d) {
                    d3.select(this).attr('stroke-opacity', 0.3).attr('stroke-width', d => linkScale(d.value));
                    tooltip.classList.remove('visible');
                });

            // Draw nodes
            const node = g.append('g')
                .attr('class', 'nodes')
                .selectAll('g')
                .data(displayNodes)
                .enter()
                .append('g')
                .style('cursor', networkParams.layout === 'force' ? 'grab' : 'pointer')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            // Node circles - colored by sector if clustering
            node.append('circle')
                .attr('r', d => sizeScale(d.output))
                .attr('fill', d => networkParams.clusterBySector ? sectorColors(d.sector) : '#fff')
                .attr('stroke', d => networkParams.clusterBySector ? '#fff' : nodeColor)
                .attr('stroke-width', networkParams.clusterBySector ? 2 : 1.5)
                .attr('fill-opacity', networkParams.clusterBySector ? 0.85 : 1);

            // Labels outside nodes - clean, minimal (toggleable)
            if (networkParams.showLabels) {
                node.append('text')
                    .attr('text-anchor', 'middle')
                    .attr('dy', d => sizeScale(d.output) + 10)
                    .attr('font-size', '9px')
                    .attr('font-weight', '500')
                    .attr('fill', '#555')
                    .attr('pointer-events', 'none')
                    .text(d => d.shortName.length > 12 ? d.shortName.substring(0, 10) + '‚Ä¶' : d.shortName);
            }

            node.on('mouseover', function(event, d) {
                    d3.select(this).select('circle')
                        .transition().duration(150)
                        .attr('stroke', accentColor)
                        .attr('stroke-width', 2);
                    
                    // Highlight connected links
                    link.transition().duration(150)
                        .attr('stroke-opacity', l => 
                            (l.source.id === d.id || l.target.id === d.id) ? 0.7 : 0.08
                        );
                    
                    // Dim other nodes
                    node.select('circle')
                        .transition().duration(150)
                        .attr('opacity', n => n.id === d.id ? 1 : 0.4);
                    
                    const outflowStr = config.prefix + d.outflow.toFixed(config.decimals) + config.unitShort;
                    const inflowStr = config.prefix + d.inflow.toFixed(config.decimals) + config.unitShort;
                    const outLabel = currentFlowType === 'dollars' ? 'Sells to others' : 'Sends waste to';
                    const inLabel = currentFlowType === 'dollars' ? 'Buys from others' : 'Receives waste from';
                    
                    const sectorBadge = networkParams.clusterBySector ? 
                        `<div style="font-size:0.65rem;color:#888;margin-top:2px;">${d.sector}</div>` : '';
                    
                    tooltip.innerHTML = `
                        <div class="tooltip-title" style="font-size:1rem;">${d.name}</div>
                        ${sectorBadge}
                        <div style="margin:8px 0;padding:8px 0;border-top:1px solid #e5e5e5;border-bottom:1px solid #e5e5e5;">
                            <div style="font-size:1.5rem;font-weight:700;color:#1a1a1a;">$${d.output.toFixed(1)}B</div>
                            <div style="font-size:0.7rem;color:#888;">Economic Output</div>
                        </div>
                        <div style="font-size:0.7rem;color:#888;margin-bottom:4px;text-transform:uppercase;">${config.name}</div>
                        <div class="tooltip-row"><span class="tooltip-label">${outLabel}</span><span class="tooltip-value" style="color:#10b981;">${outflowStr}</span></div>
                        <div class="tooltip-row"><span class="tooltip-label">${inLabel}</span><span class="tooltip-value" style="color:${config.color};">${inflowStr}</span></div>
                    `;
                    tooltip.style.left = (event.clientX + 15) + 'px';
                    tooltip.style.top = (event.clientY + 15) + 'px';
                    tooltip.classList.add('visible');
                    
                    updateSectorDetails(d.originalIndex ?? d.id);
                })
                .on('mouseout', function(event, d) {
                    d3.select(this).select('circle')
                        .transition().duration(150)
                        .attr('stroke', networkParams.clusterBySector ? '#fff' : nodeColor)
                        .attr('stroke-width', networkParams.clusterBySector ? 2 : 1.5);
                    
                    link.transition().duration(150).attr('stroke-opacity', 0.3);
                    node.select('circle').transition().duration(150).attr('opacity', 1);
                    tooltip.classList.remove('visible');
                });

            // Curved link path generator
            function linkArc(d) {
                const dx = d.target.x - d.source.x;
                const dy = d.target.y - d.source.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // Curve amount based on distance
                const curve = dist * 0.3;
                
                if (d.isSelf) {
                    const nodeR = sizeScale(displayNodes[d.source.id ?? d.source]?.output || 20);
                    const r = nodeR + 15;
                    const x = d.source.x;
                    const y = d.source.y - nodeR;
                    return `M${x},${y} A${r},${r} 0 1,1 ${x + 0.1},${y}`;
                }
                
                // Quadratic curve for normal links
                const midX = (d.source.x + d.target.x) / 2;
                const midY = (d.source.y + d.target.y) / 2;
                
                // Perpendicular offset for curve
                const nx = -dy / dist;
                const ny = dx / dist;
                const cx = midX + nx * curve * 0.3;
                const cy = midY + ny * curve * 0.3;
                
                return `M${d.source.x},${d.source.y} Q${cx},${cy} ${d.target.x},${d.target.y}`;
            }

            // Padding from edges
            const padding = 50;
            
            simulation.on('tick', () => {
                // Keep nodes within bounds for all layouts
                displayNodes.forEach(d => {
                    if (d.fx === undefined || d.fx === null) {
                        d.x = Math.max(padding, Math.min(width - padding, d.x || width / 2));
                    }
                    if (d.fy === undefined || d.fy === null) {
                        d.y = Math.max(padding, Math.min(height - padding, d.y || height / 2));
                    }
                });
                
                link.attr('d', linkArc);
                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            function dragstarted(event, d) {
                if (networkParams.layout !== 'force') return;
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
                d3.select(this).style('cursor', 'grabbing');
            }

            function dragged(event, d) {
                if (networkParams.layout !== 'force') return;
                // Keep dragged nodes within bounds
                d.fx = Math.max(padding, Math.min(width - padding, event.x));
                d.fy = Math.max(padding, Math.min(height - padding, event.y));
            }

            function dragended(event, d) {
                if (networkParams.layout !== 'force') return;
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
                d3.select(this).style('cursor', 'grab');
            }

            // Add sector legend when clustering is enabled
            if (networkParams.clusterBySector) {
                const legend = svg.append('g')
                    .attr('class', 'legend')
                    .attr('transform', `translate(15, 15)`);

                const uniqueSectors = [...new Set(displayNodes.map(n => n.sector))].slice(0, 10);
                
                uniqueSectors.forEach((sector, i) => {
                    const row = legend.append('g')
                        .attr('transform', `translate(0, ${i * 16})`);
                    
                    row.append('circle')
                        .attr('r', 5)
                        .attr('cx', 6)
                        .attr('cy', 0)
                        .attr('fill', sectorColors(sector));
                    
                    row.append('text')
                        .attr('x', 16)
                        .attr('y', 3)
                        .attr('font-size', '9px')
                        .attr('fill', '#666')
                        .text(sector.length > 20 ? sector.substring(0, 18) + '‚Ä¶' : sector);
                });
            }

            // Node count info
            svg.append('text')
                .attr('x', width - 10)
                .attr('y', height - 10)
                .attr('text-anchor', 'end')
                .attr('font-size', '10px')
                .attr('fill', '#aaa')
                .text(`${displayNodes.length} nodes ‚Ä¢ ${links.length} links`);

            // Reset zoom to default (no transform)
            svg.call(zoom.transform, d3.zoomIdentity);

            networkElements = { svg, nodes: displayNodes, links, simulation };
        }

        function createChordDiagram() {
            const container = document.getElementById('chord-chart');
            if (!container || !circularityData) return;
            
            const flowData = getCurrentFlowData();
            if (!flowData) return;
            
            container.innerHTML = '';
            
            // Chord diagram not supported for 411 industries (too complex)
            const industries = circularityData.industries || circularityData.sectors;
            if (industries.length > 50) {
                container.innerHTML = `
                    <div style="display:flex;align-items:center;justify-content:center;height:400px;color:#666;text-align:center;padding:40px;">
                        <div>
                            <div style="font-size:2rem;margin-bottom:12px;">üìä</div>
                            <div style="font-size:0.9rem;font-weight:600;margin-bottom:8px;">Chord diagram not available</div>
                            <div style="font-size:0.8rem;color:#888;">With ${industries.length} industries, please use the Network view.<br>Chord diagrams work best with ‚â§50 items.</div>
                        </div>
                    </div>
                `;
                return;
            }
            
            const showSelfLoops = document.getElementById('show-self-loops')?.checked ?? true;
            const config = flowTypeConfig[currentFlowType];
            
            // Prepare matrix from selected flow type (only works with old sector-based data)
            if (!flowData.matrix) {
                container.innerHTML = `
                    <div style="display:flex;align-items:center;justify-content:center;height:400px;color:#666;">
                        Chord diagram requires matrix data
                    </div>
                `;
                return;
            }
            
            let matrix = flowData.matrix.map(row => [...row]);
            const sectors = circularityData.sectors;
            const n = sectors.length;
            
            // Optionally remove self-loops
            if (!showSelfLoops) {
                for (let i = 0; i < n; i++) {
                    matrix[i][i] = 0;
                }
            }
            
            const containerWidth = container.clientWidth || 600;
            const width = Math.min(containerWidth, 600);
            const height = 600;
            const outerRadius = Math.min(width, height) / 2 - 80;
            const innerRadius = outerRadius - 20;
            
            if (outerRadius < 50) return; // Container not ready

            // Color scale
            const color = d3.scaleOrdinal()
                .domain(sectors)
                .range([
                    '#2563eb', '#16a34a', '#ea580c', '#8b5cf6', '#ec4899',
                    '#06b6d4', '#84cc16', '#f97316', '#6366f1', '#14b8a6',
                    '#f43f5e', '#a855f7', '#22c55e', '#3b82f6', '#eab308',
                    '#64748b', '#0ea5e9', '#d946ef', '#10b981', '#f59e0b'
                ]);

            const svg = d3.select('#chord-chart')
                .append('svg')
                .attr('width', width)
                .attr('height', height)
                .append('g')
                .attr('transform', `translate(${width / 2}, ${height / 2})`);

            // Create chord layout
            const chord = d3.chord()
                .padAngle(0.04)
                .sortSubgroups(d3.descending)
                .sortChords(d3.descending);

            const chords = chord(matrix);

            // Arc generator for groups
            const arc = d3.arc()
                .innerRadius(innerRadius)
                .outerRadius(outerRadius);

            // Ribbon generator for chords
            const ribbon = d3.ribbon()
                .radius(innerRadius);

            const tooltip = document.getElementById('tooltip');

            // Draw groups (sectors)
            const groups = svg.append('g')
                .selectAll('g')
                .data(chords.groups)
                .enter()
                .append('g')
                .attr('class', 'chord-group');

            groups.append('path')
                .attr('d', arc)
                .attr('fill', d => color(sectors[d.index]))
                .attr('stroke', '#fff')
                .attr('stroke-width', 1)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    highlightSector(d.index);
                    showSectorTooltip(event, d);
                    updateSectorDetails(d.index);
                })
                .on('mousemove', function(event) {
                    tooltip.style.left = (event.clientX + 12) + 'px';
                    tooltip.style.top = (event.clientY + 12) + 'px';
                })
                .on('mouseout', function() {
                    if (!selectedChordSector) {
                        resetChordHighlight();
                    }
                    tooltip.classList.remove('visible');
                })
                .on('click', function(event, d) {
                    selectChordSector(d.index);
                });

            // Sector labels
            groups.append('text')
                .each(d => { d.angle = (d.startAngle + d.endAngle) / 2; })
                .attr('dy', '0.35em')
                .attr('transform', d => `
                    rotate(${(d.angle * 180 / Math.PI - 90)})
                    translate(${outerRadius + 10})
                    ${d.angle > Math.PI ? 'rotate(180)' : ''}
                `)
                .attr('text-anchor', d => d.angle > Math.PI ? 'end' : 'start')
                .attr('font-size', '0.6rem')
                .attr('fill', '#666')
                .text(d => {
                    const name = sectors[d.index];
                    return name.length > 20 ? name.substring(0, 18) + '...' : name;
                });

            // Draw ribbons (flows)
            const ribbons = svg.append('g')
                .selectAll('path')
                .data(chords)
                .enter()
                .append('path')
                .attr('class', 'chord-ribbon')
                .attr('d', ribbon)
                .attr('fill', d => color(sectors[d.source.index]))
                .attr('fill-opacity', 0.6)
                .attr('stroke', '#fff')
                .attr('stroke-width', 0.5)
                .style('cursor', 'pointer')
                .on('mouseover', function(event, d) {
                    d3.select(this).attr('fill-opacity', 0.9);
                    showFlowTooltip(event, d);
                })
                .on('mousemove', function(event) {
                    tooltip.style.left = (event.clientX + 12) + 'px';
                    tooltip.style.top = (event.clientY + 12) + 'px';
                })
                .on('mouseout', function() {
                    d3.select(this).attr('fill-opacity', selectedChordSector !== null ? 0.1 : 0.6);
                    tooltip.classList.remove('visible');
                });

            chordElements = { svg, groups, ribbons, color, sectors };
        }

        function highlightSector(index) {
            if (!chordElements || !circularityData) return;
            
            chordElements.ribbons
                .attr('fill-opacity', d => 
                    (d.source.index === index || d.target.index === index) ? 0.8 : 0.1
                );
                
            chordElements.groups.selectAll('path')
                .attr('opacity', d => d.index === index ? 1 : 0.3);
        }

        function resetChordHighlight() {
            if (!chordElements) return;
            
            chordElements.ribbons.attr('fill-opacity', 0.6);
            chordElements.groups.selectAll('path').attr('opacity', 1);
            
            document.getElementById('sector-details').innerHTML = `
                <div class="empty-state" style="padding:30px 10px;">
                    <div class="empty-state-text" style="font-size:0.8rem;">Hover over a sector</div>
                    <div class="empty-state-hint">to see flow details</div>
                </div>
            `;
        }

        function selectChordSector(index) {
            if (selectedChordSector === index) {
                selectedChordSector = null;
                document.getElementById('clear-chord').style.display = 'none';
                resetChordHighlight();
            } else {
                selectedChordSector = index;
                document.getElementById('clear-chord').style.display = 'block';
                highlightSector(index);
                updateSectorDetails(index);
            }
        }

        function clearChordSelection() {
            selectedChordSector = null;
            document.getElementById('clear-chord').style.display = 'none';
            resetChordHighlight();
        }

        function showSectorTooltip(event, d) {
            if (!circularityData) return;
            const flowData = getCurrentFlowData();
            if (!flowData) return;
            
            const sector = circularityData.sectors[d.index];
            const info = circularityData.sector_info[sector];
            if (!info) return;
            
            const config = flowTypeConfig[currentFlowType];
            const matrix = flowData.matrix;
            
            // Calculate flows for current flow type
            let inflow = 0, outflow = 0, internal = matrix[d.index][d.index];
            for (let i = 0; i < circularityData.sectors.length; i++) {
                outflow += matrix[d.index][i];
                inflow += matrix[i][d.index];
            }
            
            const formatVal = (v) => config.prefix + v.toFixed(config.decimals) + config.unitShort;
            const outLabel = currentFlowType === 'dollars' ? 'Sells to others' : 'Sends waste';
            const inLabel = currentFlowType === 'dollars' ? 'Buys from others' : 'Receives waste';
            const internalLabel = currentFlowType === 'dollars' ? 'Internal trade' : 'Internal waste';
            
            const tooltip = document.getElementById('tooltip');
            
            tooltip.innerHTML = `
                <div class="tooltip-title">${sector}</div>
                <div class="tooltip-row"><span class="tooltip-label">Economic output</span><span class="tooltip-value">$${info.output.toFixed(0)}B</span></div>
                <div style="font-size:0.65rem;color:#888;margin:6px 0 2px;text-transform:uppercase;">${config.name}</div>
                <div class="tooltip-row"><span class="tooltip-label">${outLabel}</span><span class="tooltip-value">${formatVal(outflow - internal)}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">${inLabel}</span><span class="tooltip-value">${formatVal(inflow - internal)}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">${internalLabel}</span><span class="tooltip-value">${formatVal(internal)}</span></div>
            `;
            tooltip.classList.add('visible');
        }

        function showFlowTooltip(event, d) {
            if (!circularityData) return;
            const flowData = getCurrentFlowData();
            if (!flowData) return;
            
            const config = flowTypeConfig[currentFlowType];
            const fromSector = circularityData.sectors[d.source.index];
            const toSector = circularityData.sectors[d.target.index];
            const value = flowData.matrix[d.source.index][d.target.index];
            const tooltip = document.getElementById('tooltip');
            
            const isSelf = d.source.index === d.target.index;
            const formatVal = (v) => config.prefix + v.toFixed(config.decimals) + config.unitShort;
            const flowLabel = currentFlowType === 'dollars' ? (isSelf ? 'Internal Flow' : 'Material Flow') : `${config.name} Flow`;
            
            tooltip.innerHTML = `
                <div class="tooltip-title">${flowLabel}</div>
                <div class="tooltip-row"><span class="tooltip-label">From</span><span class="tooltip-value">${fromSector.substring(0, 25)}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">To</span><span class="tooltip-value">${toSector.substring(0, 25)}</span></div>
                <div class="tooltip-row"><span class="tooltip-label">Value</span><span class="tooltip-value" style="color:${config.color}">${formatVal(value)}</span></div>
            `;
            tooltip.classList.add('visible');
        }

        function updateSectorDetails(index) {
            if (!circularityData) return;
            
            const flowData = getCurrentFlowData();
            if (!flowData) return;
            
            const industries = circularityData.industries || circularityData.sectors;
            const industry = industries[index];
            if (!industry) return;
            
            const name = industry.name || industry;
            const sector = industry.sector || 'Other';
            const output = industry.output || circularityData.sector_info?.[industry]?.output || 0;
            
            const config = flowTypeConfig[currentFlowType];
            const topFlows = flowData.top_flows || [];
            
            // Find flows involving this industry
            const inflows = [];
            const outflows = [];
            let totalIn = 0, totalOut = 0, internal = 0;
            
            topFlows.forEach(f => {
                if (f.to === index && f.from !== index) {
                    totalIn += f.value;
                    const fromInd = industries[f.from];
                    inflows.push({ 
                        name: fromInd?.name || fromInd || `Industry ${f.from}`, 
                        value: f.value 
                    });
                }
                if (f.from === index && f.to !== index) {
                    totalOut += f.value;
                    const toInd = industries[f.to];
                    outflows.push({ 
                        name: toInd?.name || toInd || `Industry ${f.to}`, 
                        value: f.value 
                    });
                }
                if (f.from === index && f.to === index) {
                    internal = f.value;
                }
            });
            
            inflows.sort((a, b) => b.value - a.value);
            outflows.sort((a, b) => b.value - a.value);
            
            const formatVal = (v) => config.prefix + v.toFixed(config.decimals) + config.unitShort;
            const outLabel = currentFlowType === 'dollars' ? 'Sells to others' : 'Waste sent';
            const inLabel = currentFlowType === 'dollars' ? 'Buys from others' : 'Waste received';
            const internalLabel = currentFlowType === 'dollars' ? 'Internal' : 'Internal waste';
            const suppliersLabel = currentFlowType === 'dollars' ? 'Top Suppliers' : 'Top Waste Sources';
            const customersLabel = currentFlowType === 'dollars' ? 'Top Customers' : 'Top Waste Recipients';
            
            document.getElementById('sector-details').innerHTML = `
                <div class="sector-detail-header">
                    <div class="sector-detail-name">${name}</div>
                    <div class="sector-detail-output" style="font-size:0.7rem;color:#888;">${sector} ¬∑ $${output.toFixed(1)}B output</div>
                </div>
                <div style="font-size:0.7rem;color:#888;margin:8px 0 4px;text-transform:uppercase;font-weight:500;">${config.name}</div>
                <div class="sector-detail-row">
                    <span class="sector-detail-label">${outLabel}</span>
                    <span class="sector-detail-value">${formatVal(totalOut)}</span>
                </div>
                <div class="sector-detail-row">
                    <span class="sector-detail-label">${inLabel}</span>
                    <span class="sector-detail-value">${formatVal(totalIn)}</span>
                </div>
                ${internal > 0 ? `
                <div class="sector-detail-row">
                    <span class="sector-detail-label">${internalLabel}</span>
                    <span class="sector-detail-value" style="color:#16a34a">${formatVal(internal)}</span>
                </div>
                ` : ''}
                
                ${inflows.length > 0 ? `
                <div style="margin-top:16px;font-size:0.7rem;font-weight:600;color:#666;text-transform:uppercase;">${suppliersLabel}</div>
                ${inflows.slice(0, 4).map(f => `
                    <div style="display:flex;justify-content:space-between;padding:6px 0;font-size:0.75rem;">
                        <span style="color:#666;">${f.name.substring(0, 22)}</span>
                        <span style="font-family:'IBM Plex Mono',monospace;">${formatVal(f.value)}</span>
                    </div>
                `).join('')}
                ` : ''}
                
                ${outflows.length > 0 ? `
                <div style="margin-top:12px;font-size:0.7rem;font-weight:600;color:#666;text-transform:uppercase;">${customersLabel}</div>
                ${outflows.slice(0, 4).map(f => `
                    <div style="display:flex;justify-content:space-between;padding:6px 0;font-size:0.75rem;">
                        <span style="color:#666;">${f.name.substring(0, 22)}</span>
                        <span style="font-family:'IBM Plex Mono',monospace;">${formatVal(f.value)}</span>
                    </div>
                `).join('')}
                ` : ''}
            `;
        }

        function renderTopFlows() {
            if (!circularityData) return;
            
            const flowData = getCurrentFlowData();
            if (!flowData || !flowData.top_flows) return;
            
            const config = flowTypeConfig[currentFlowType];
            const formatVal = (v) => config.prefix + v.toFixed(config.decimals) + config.unitShort;
            const industries = circularityData.industries || circularityData.sectors;
            
            const flows = flowData.top_flows
                .filter(f => f.from !== f.to)
                .slice(0, 15);
            
            if (flows.length === 0) {
                document.getElementById('top-flows-list').innerHTML = `
                    <div style="text-align:center;padding:20px;color:#888;font-size:0.8rem;">
                        No significant flows for this category
                    </div>
                `;
                return;
            }
            
            const maxValue = Math.max(...flows.map(f => f.value));
            
            const getName = (idx) => {
                const ind = industries[idx];
                const name = ind?.name || ind || `Industry ${idx}`;
                return name.length > 14 ? name.substring(0, 12) + '‚Ä¶' : name;
            };
            
            document.getElementById('top-flows-list').innerHTML = flows.map(f => `
                <div class="flow-item" data-from="${f.from}" data-to="${f.to}">
                    <div class="flow-item-header">
                        <div class="flow-item-sectors">
                            <span>${getName(f.from)}</span>
                            <span class="flow-arrow">‚Üí</span>
                            <span>${getName(f.to)}</span>
                        </div>
                        <div class="flow-item-value">${formatVal(f.value)}</div>
                    </div>
                    <div class="flow-item-bar">
                        <div class="flow-item-bar-fill" style="width:${(f.value / maxValue * 100)}%;background:${config.color};"></div>
                    </div>
                </div>
            `).join('');
            
            document.querySelectorAll('.flow-item').forEach(item => {
                item.addEventListener('mouseenter', () => {
                    const fromIdx = parseInt(item.dataset.from);
                    highlightSector(fromIdx);
                });
                item.addEventListener('mouseleave', () => {
                    if (!selectedChordSector) {
                        resetChordHighlight();
                    }
                });
            });
        }
    </script>
</body>
</html>
